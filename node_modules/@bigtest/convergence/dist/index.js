(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
	typeof define === 'function' && define.amd ? define(['exports'], factory) :
	(factory((global.BigTest = global.BigTest || {}, global.BigTest.Convergence = {})));
}(this, (function (exports) { 'use strict';

function _typeof(obj) {
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function (obj) {
      return typeof obj;
    };
  } else {
    _typeof = function (obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

var _sPO = Object.setPrototypeOf || function _sPO(o, p) {
  o.__proto__ = p;
  return o;
};

var _construct = typeof Reflect === "object" && Reflect.construct || function _construct(Parent, args, Class) {
  var Constructor,
      a = [null];
  a.push.apply(a, args);
  Constructor = Parent.bind.apply(Parent, a);
  return _sPO(new Constructor(), Class.prototype);
};

function _toConsumableArray(arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

    return arr2;
  } else {
    return Array.from(arr);
  }
}

function convergeOn(assertion) {
  var timeout = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2000;
  var always = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  var context = this;
  var start = Date.now();
  var interval = 10;
  var stats = {
    start: start,
    runs: 0,
    end: start,
    elapsed: 0,
    always: always,
    timeout: timeout,
    value: undefined
  };
  return new Promise(function (resolve, reject) {
    (function loop() {
      stats.runs += 1;

      try {
        var results = assertion.call(context);
        var doLoop = Date.now() - start < timeout;

        if (always && doLoop) {
          setTimeout(loop, interval);
        } else if (results === false) {
          throw new Error('convergent assertion returned `false`');
        } else if (!always && !doLoop) {
          throw new Error('convergent assertion was successful, ' + "but exceeded the ".concat(timeout, "ms timeout"));
        } else {
          stats.end = Date.now();
          stats.elapsed = stats.end - start;
          stats.value = results;
          resolve(stats);
        }
      } catch (error) {
        var _doLoop = Date.now() - start < timeout;

        if (!always && _doLoop) {
          setTimeout(loop, interval);
        } else if (always || !_doLoop) {
          reject(error);
        }
      }
    })();
  });
}

function getElapsedSince(start, max) {
  var elapsed = Date.now() - start;

  if (elapsed >= max) {
    throw new Error("convergence exceeded the ".concat(max, "ms timeout"));
  }

  return elapsed;
}



function collectStats(accumulator, stats) {
  accumulator.runs += stats.runs;
  accumulator.elapsed += stats.elapsed;
  accumulator.end = stats.end;
  accumulator.value = stats.value;
  accumulator.stack.push(stats);
  return stats.value;
}

function isConvergence(obj) {
  return !!obj && _typeof(obj) === 'object' && '_stack' in obj && Array.isArray(obj._stack) && 'timeout' in obj && typeof obj.timeout === 'function' && 'run' in obj && typeof obj.run === 'function';
}
function runAssertion(subject, arg, last, stats) {
  var timeout = stats.timeout - getElapsedSince(stats.start, stats.timeout);
  var assert = subject.assert.bind(null, arg);

  if (subject.always && !last) {
    if (subject.timeout) {
      timeout = Math.min(timeout, subject.timeout);
    } else {
      timeout = Math.max(stats.timeout / 10, 20);
    }
  }

  return convergeOn(assert, timeout, subject.always).then(function (convergeStats) {
    return collectStats(stats, convergeStats);
  });
}
function runExec(subject, arg, last, stats) {
  var start = Date.now();
  var result = subject.exec(arg);

  var collectExecStats = function collectExecStats(value) {
    return collectStats(stats, {
      start: start,
      runs: 1,
      end: Date.now(),
      elapsed: getElapsedSince(start, stats.timeout),
      value: value
    });
  };

  if (isConvergence(result)) {
    var timeout = stats.timeout - getElapsedSince(start, stats.timeout);

    if (!last) {
      result = result.do(function (ret) {
        return ret;
      });
    }

    return result.timeout(timeout).run().then(function (convergeStats) {
      return collectStats(stats, convergeStats);
    });
  } else if (result && typeof result.then === 'function') {
    return result.then(collectExecStats);
  } else {
    return collectExecStats(result);
  }
}

var Convergence = function () {
  function Convergence() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var prev = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    _classCallCheck(this, Convergence);

    if (typeof options === 'number') {
      options = {
        _timeout: options
      };
    }

    var _options = options,
        _options$_timeout = _options._timeout,
        _timeout = _options$_timeout === void 0 ? prev._timeout || 2000 : _options$_timeout,
        _options$_stack = _options._stack,
        _stack = _options$_stack === void 0 ? [] : _options$_stack;

    _stack = _toConsumableArray(prev._stack || []).concat(_toConsumableArray(_stack));
    Object.defineProperties(this, {
      _timeout: {
        value: _timeout
      },
      _stack: {
        value: _stack
      }
    });
  }

  _createClass(Convergence, [{
    key: "timeout",
    value: function timeout(_timeout2) {
      if (typeof _timeout2 !== 'undefined') {
        return new this.constructor(_timeout2, this);
      } else {
        return this._timeout;
      }
    }
  }, {
    key: "once",
    value: function once(assert) {
      return new this.constructor({
        _stack: [{
          assert: assert
        }]
      }, this);
    }
  }, {
    key: "always",
    value: function always(assert, timeout) {
      return new this.constructor({
        _stack: [{
          always: true,
          timeout: timeout,
          assert: assert
        }]
      }, this);
    }
  }, {
    key: "do",
    value: function _do(exec) {
      return new this.constructor({
        _stack: [{
          exec: exec
        }]
      }, this);
    }
  }, {
    key: "append",
    value: function append(convergence) {
      if (!(convergence instanceof Convergence)) {
        throw new Error('.append() only works with convergence instances');
      }

      return new this.constructor({
        _stack: convergence._stack
      }, this);
    }
  }, {
    key: "run",
    value: function run() {
      var _this = this;

      var start = Date.now();
      var stats = {
        start: start,
        runs: 0,
        end: start,
        elapsed: 0,
        value: undefined,
        timeout: this._timeout,
        stack: []
      };
      return this._stack.reduce(function (promise, subject, i) {
        var last = i === _this._stack.length - 1;
        return promise.then(function (ret) {
          if (subject.assert) {
            return runAssertion(subject, ret, last, stats);
          } else if (subject.exec) {
            return runExec(subject, ret, last, stats);
          }
        });
      }, Promise.resolve()).then(function () {
        return stats;
      });
    }
  }]);
  return Convergence;
}();

Convergence.isConvergence = isConvergence;

exports.isConvergence = isConvergence;
exports.convergeOn = convergeOn;
exports['default'] = Convergence;

Object.defineProperty(exports, '__esModule', { value: true });

})));
