[
  {
    "comment": "/**\n * ```\n * import Convergence from '@bigtest/convergence'\n * ```\n *\n * Convergences are powerful, immutable, reusable, and composable\n * assertions that allow you to know immediately when a desired state\n * is achieved.\n *\n * ``` javascript\n * setTimeout(() => foo = 'bar', 100)\n * await new Convergence().when(() => foo === 'bar')\n * console.log(foo) // => \"bar\"\n * ```\n *\n * By default, a convergence will converge before or after `2000ms`\n * depending on the type of assertions defined. This can be configured\n * by providing a timeout when initializing the convergence, or by\n * using the [`#timeout()`](#/Convergence#timeout) method.\n *\n * ``` javascript\n * new Convergence(100)\n * new Convergence().timeout(5000)\n * ```\n *\n * Using [`#when()`](#when), the assertions will run multiple times\n * until they pass. Similarly, [`#always()`](#always) ensures that\n * assertions keep passing for a period of time.\n *\n * ``` javascript\n * // converges when `foo` is equal to `'bar'` within 100ms\n * new Convergence(100).when(() => foo === 'bar')\n * // converges after `foo` is equal to `'bar'` for at least 100ms\n * new Convergence(100).always(() => foo === 'bar')\n * ```\n *\n * Convergences are immutable, and as such, it's methods return new\n * instances. This allows you to compose multiple convergences and\n * start each of them separately using their respective\n * [`#run()`](#/Convergence#run) methods.\n *\n * ``` javascript\n * let converge = new Convergence(300)\n * let convergeFoo = converge.when(() => foo === 'foo')\n * let convergeFooBar = convergeFoo.when(() => foo === 'bar')\n * let convergeFooBarBaz = convergeFooBar.when(() => foo === 'baz')\n *\n * setTimeout(() => foo = 'foo', 100)\n * setTimeout(() => foo = 'bar', 200)\n * setTimeout(() => foo = 'baz', 150)\n *\n * // resolves after 100ms\n * convergeFoo.run()\n * // resolves after 200ms\n * convergeFooBar.run()\n * // rejects after 300ms since it wasn't `baz` _after_ `bar`\n * convergeFooBarBaz.run()\n * ```\n *\n * Convergences are also thennable, which immediately invokes\n * [`#run()`](#/Convergence#run). This allows them to be able to be used anywhere\n * Promises can be used in most cases.\n *\n * ``` javascript\n * async function onceBarAlwaysBar() {\n *   await new Convergence()\n *     .when(() => foo === 'bar')\n *     .always(() => foo === 'bar')\n * }\n *\n * Promise.race([\n *   onceBarAlwaysBar(),\n *   new Convergence().when(() => foo === 'baz')\n * ])\n * ```\n */",
    "meta": {
      "range": [
        2530,
        13926
      ],
      "filename": "convergence.js",
      "lineno": 85,
      "columnno": 0,
      "path": "/src",
      "code": {
        "id": "astnode100000274",
        "name": "Convergence",
        "type": "ClassDeclaration",
        "paramnames": [
          "options",
          "previous"
        ]
      }
    },
    "classdesc": "```\nimport Convergence from '@bigtest/convergence'\n```\n\nConvergences are powerful, immutable, reusable, and composable\nassertions that allow you to know immediately when a desired state\nis achieved.\n\n``` javascript\nsetTimeout(() => foo = 'bar', 100)\nawait new Convergence().when(() => foo === 'bar')\nconsole.log(foo) // => \"bar\"\n```\n\nBy default, a convergence will converge before or after `2000ms`\ndepending on the type of assertions defined. This can be configured\nby providing a timeout when initializing the convergence, or by\nusing the [`#timeout()`](#/Convergence#timeout) method.\n\n``` javascript\nnew Convergence(100)\nnew Convergence().timeout(5000)\n```\n\nUsing [`#when()`](#when), the assertions will run multiple times\nuntil they pass. Similarly, [`#always()`](#always) ensures that\nassertions keep passing for a period of time.\n\n``` javascript\n// converges when `foo` is equal to `'bar'` within 100ms\nnew Convergence(100).when(() => foo === 'bar')\n// converges after `foo` is equal to `'bar'` for at least 100ms\nnew Convergence(100).always(() => foo === 'bar')\n```\n\nConvergences are immutable, and as such, it's methods return new\ninstances. This allows you to compose multiple convergences and\nstart each of them separately using their respective\n[`#run()`](#/Convergence#run) methods.\n\n``` javascript\nlet converge = new Convergence(300)\nlet convergeFoo = converge.when(() => foo === 'foo')\nlet convergeFooBar = convergeFoo.when(() => foo === 'bar')\nlet convergeFooBarBaz = convergeFooBar.when(() => foo === 'baz')\n\nsetTimeout(() => foo = 'foo', 100)\nsetTimeout(() => foo = 'bar', 200)\nsetTimeout(() => foo = 'baz', 150)\n\n// resolves after 100ms\nconvergeFoo.run()\n// resolves after 200ms\nconvergeFooBar.run()\n// rejects after 300ms since it wasn't `baz` _after_ `bar`\nconvergeFooBarBaz.run()\n```\n\nConvergences are also thennable, which immediately invokes\n[`#run()`](#/Convergence#run). This allows them to be able to be used anywhere\nPromises can be used in most cases.\n\n``` javascript\nasync function onceBarAlwaysBar() {\n  await new Convergence()\n    .when(() => foo === 'bar')\n    .always(() => foo === 'bar')\n}\n\nPromise.race([\n  onceBarAlwaysBar(),\n  new Convergence().when(() => foo === 'baz')\n])\n```",
    "name": "Convergence",
    "longname": "Convergence",
    "kind": "class",
    "scope": "global",
    "description": "The constructor actually takes two params, `options` and\n`previous`. Publicly, `options` is `timeout`, but internally, new\ninstances receive new `options` in addition to the `previous`\ninstance. This allows things that extend convergences to still be\nimmutable, but requires that they have deeper knowledge of the\ninternal API.",
    "params": [
      {
        "type": {
          "names": [
            "Number"
          ]
        },
        "description": "Initial convergence timeout",
        "name": "timeout"
      }
    ]
  },
  {
    "comment": "/**\n * Returns `true` if the object has common convergence properties of\n * the correct type.\n *\n * ``` javascript\n * let result = maybeConvergence()\n *\n * if (isConvergence(result)) {\n *   await result.do(something).timeout(100)\n * } else {\n *   something(result)\n * }\n * ```\n *\n * @static\n * @alias Convergence.isConvergence\n * @param {Object} obj - A possible convergence object\n * @returns {Boolean}\n */",
    "meta": {
      "range": [
        1622,
        1869
      ],
      "filename": "utils.js",
      "lineno": 66,
      "columnno": 0,
      "path": "/src",
      "code": {
        "id": "astnode100000710",
        "name": "exports.isConvergence",
        "type": "FunctionDeclaration",
        "paramnames": [
          "obj"
        ]
      }
    },
    "description": "Returns `true` if the object has common convergence properties of\nthe correct type.\n\n``` javascript\nlet result = maybeConvergence()\n\nif (isConvergence(result)) {\n  await result.do(something).timeout(100)\n} else {\n  something(result)\n}\n```",
    "scope": "static",
    "alias": "Convergence.isConvergence",
    "params": [
      {
        "type": {
          "names": [
            "Object"
          ]
        },
        "description": "A possible convergence object",
        "name": "obj"
      }
    ],
    "returns": [
      {
        "type": {
          "names": [
            "Boolean"
          ]
        }
      }
    ],
    "name": "isConvergence",
    "longname": "Convergence.isConvergence",
    "kind": "function",
    "memberof": "Convergence"
  },
  {
    "comment": "/**\n   * Returns a new convergence instance with an additional assertion.\n   * This assertion is run repeatedly to ensure it passes throughout\n   * the timeout. If the assertion fails at any point during the\n   * timeout, the convergence will fail.\n   *\n   * ``` javascript\n   * // would converge after `foo` remains `'foo'` for at least 100ms\n   * new Convergence(100).always(() => foo === 'foo')\n   * ```\n   *\n   * When an always assertion is encountered at the end of a\n   * convergence, the timeout defaults to the remaining time for the\n   * current running instance; minumum `20ms`. When not at the ned of\n   * a convergence, it defaults to one-tenth of the total timeout.\n   *\n   * ``` javascript\n   * let convergeFooThenBar = new Convergence(1000)\n   * // would continue after `foo` remains `'foo'` for at least 100ms\n   *   .always(() => foo === 'foo')\n   * // then have any time remaining to converge on `foo` being `'bar'`\n   *   .when(() => foo === 'bar')\n   * ```\n   *\n   * Given a timeout, it is capped at the remaining timeout for the\n   * current running instance.\n   *\n   * ``` javascript\n   * let convergeFooThenBar = new Convergence(100)\n   * // would continue after `foo` remains `'foo'` for at least 50ms\n   *   .always(() => foo === 'foo', 50)\n   * // then have 50ms remaining to converge on `foo` being `'bar'`\n   *   .when(() => foo === 'bar')\n   * // and a maximum of ~50ms to converge on it remaining `bar`\n   *   .always(() => foo === 'bar', 100)\n   * ```\n   *\n   * @param {Function} assertion - The assertion to converge on\n   * @param {Number} [timeout] - The timeout to use, capped at the\n   * remaining timeout.\n   * @returns {Convergence} A new convergence instance\n   */",
    "meta": {
      "range": [
        6643,
        6806
      ],
      "filename": "convergence.js",
      "lineno": 207,
      "columnno": 2,
      "path": "/src",
      "code": {
        "id": "astnode100000382",
        "name": "Convergence#always",
        "type": "MethodDefinition",
        "paramnames": [
          "assertion",
          "timeout"
        ]
      },
      "vars": {
        "": null
      }
    },
    "description": "Returns a new convergence instance with an additional assertion.\nThis assertion is run repeatedly to ensure it passes throughout\nthe timeout. If the assertion fails at any point during the\ntimeout, the convergence will fail.\n\n``` javascript\n// would converge after `foo` remains `'foo'` for at least 100ms\nnew Convergence(100).always(() => foo === 'foo')\n```\n\nWhen an always assertion is encountered at the end of a\nconvergence, the timeout defaults to the remaining time for the\ncurrent running instance; minumum `20ms`. When not at the ned of\na convergence, it defaults to one-tenth of the total timeout.\n\n``` javascript\nlet convergeFooThenBar = new Convergence(1000)\n// would continue after `foo` remains `'foo'` for at least 100ms\n  .always(() => foo === 'foo')\n// then have any time remaining to converge on `foo` being `'bar'`\n  .when(() => foo === 'bar')\n```\n\nGiven a timeout, it is capped at the remaining timeout for the\ncurrent running instance.\n\n``` javascript\nlet convergeFooThenBar = new Convergence(100)\n// would continue after `foo` remains `'foo'` for at least 50ms\n  .always(() => foo === 'foo', 50)\n// then have 50ms remaining to converge on `foo` being `'bar'`\n  .when(() => foo === 'bar')\n// and a maximum of ~50ms to converge on it remaining `bar`\n  .always(() => foo === 'bar', 100)\n```",
    "params": [
      {
        "type": {
          "names": [
            "function"
          ]
        },
        "description": "The assertion to converge on",
        "name": "assertion"
      },
      {
        "type": {
          "names": [
            "Number"
          ]
        },
        "optional": true,
        "description": "The timeout to use, capped at the\nremaining timeout.",
        "name": "timeout"
      }
    ],
    "returns": [
      {
        "type": {
          "names": [
            "Convergence"
          ]
        },
        "description": "A new convergence instance"
      }
    ],
    "name": "always",
    "longname": "Convergence#always",
    "kind": "function",
    "memberof": "Convergence",
    "scope": "instance"
  },
  {
    "comment": "/**\n   * Appends another convergence's queue to this convergence's queue\n   * to allow composing different convergences together.\n   *\n   * ``` javascript\n   * // would converge when `foo` equals `'bar'`\n   * let convergeBar = new Convergence().when(() => foo === 'bar')\n   *\n   * // would converge when `foo` equals `'baz'`\n   * let convergeBaz = new Convergence().when(() => foo === 'baz')\n   *\n   * // would converge when `foo` equals `'bar'` and then `'baz'`\n   * let convergeBarBaz = convergeBar.append(convergeBaz)\n   * ```\n   *\n   * @param {Convergence} convergence - A convergence instance\n   * @returns {Convergence} A new convergence instance\n   */",
    "meta": {
      "range": [
        9739,
        9965
      ],
      "filename": "convergence.js",
      "lineno": 304,
      "columnno": 2,
      "path": "/src",
      "code": {
        "id": "astnode100000421",
        "name": "Convergence#append",
        "type": "MethodDefinition",
        "paramnames": [
          "convergence"
        ]
      },
      "vars": {
        "": null
      }
    },
    "description": "Appends another convergence's queue to this convergence's queue\nto allow composing different convergences together.\n\n``` javascript\n// would converge when `foo` equals `'bar'`\nlet convergeBar = new Convergence().when(() => foo === 'bar')\n\n// would converge when `foo` equals `'baz'`\nlet convergeBaz = new Convergence().when(() => foo === 'baz')\n\n// would converge when `foo` equals `'bar'` and then `'baz'`\nlet convergeBarBaz = convergeBar.append(convergeBaz)\n```",
    "params": [
      {
        "type": {
          "names": [
            "Convergence"
          ]
        },
        "description": "A convergence instance",
        "name": "convergence"
      }
    ],
    "returns": [
      {
        "type": {
          "names": [
            "Convergence"
          ]
        },
        "description": "A new convergence instance"
      }
    ],
    "name": "append",
    "longname": "Convergence#append",
    "kind": "function",
    "memberof": "Convergence",
    "scope": "instance"
  },
  {
    "comment": "/**\n   * Returns a new convergence instance with a callback added to its\n   * queue. When a running convergence instance encounters a callback,\n   * it will be invoked with the value returned from the last function\n   * in the queue. The resulting return value will also be provided to\n   * the following function in the queue. If the return value is\n   * undefined, the previous return value will be retained.\n   *\n   * ``` javascript\n   * new Convergence()\n   *   // continues after finding a random even number\n   *   .when(() => {\n   *     let n = Math.ceil(Math.random() * 100)\n   *     return !(n % 2) && n\n   *   })\n   *   // multiplies the even number by another random number\n   *   .do((even) => {\n   *     return even * Math.ceil(Math.random() * 100)\n   *   })\n   *   // does not return, the previous value will be retained\n   *   .do((rand) => {\n   *     console.log('even number times random number = ', rand);\n   *   })\n   *   // asserts that any number times an even number is even\n   *   .always((rand) => {\n   *     let rand = Math.ceil(Math.random() * 100);\n   *     return !(rand % 2)\n   *   }, 100)\n   * ```\n   *\n   * When a promise is returned from a callback, the convergence will\n   * wait for the promise to resolve before continuing.\n   *\n   * ``` javascript\n   * new Convergence()\n   *   .when(() => foo === 'bar')\n   *   .do(() => doSomethingAsync())\n   *   .do((baz) => console.log('resolved with', baz))\n   * ```\n   *\n   * Returning other convergences from a callback is also\n   * supported. The returned convergence will be run with the current\n   * remaining timeout. This is useful when computing convergences\n   * after converging on another state.\n   *\n   * ``` javascript\n   * new Convergence()\n   *   // continue when `num` is less than 100\n   *   .when(() => num < 100)\n   *   .do(() => {\n   *     // if odd, wait until it is even\n   *     if (num % 2) {\n   *       return new Convergence()\n   *         .when(() => !(num % 2) && num)\n   *     } else {\n   *       return num;\n   *     }\n   *   })\n   * ```\n   *\n   * @param {Function} callback - The callback to execute\n   * @returns {Convergence} A new convergence instance\n   */",
    "meta": {
      "range": [
        8979,
        9074
      ],
      "filename": "convergence.js",
      "lineno": 280,
      "columnno": 2,
      "path": "/src",
      "code": {
        "id": "astnode100000404",
        "name": "Convergence#do",
        "type": "MethodDefinition",
        "paramnames": [
          "callback"
        ]
      },
      "vars": {
        "": null
      }
    },
    "description": "Returns a new convergence instance with a callback added to its\nqueue. When a running convergence instance encounters a callback,\nit will be invoked with the value returned from the last function\nin the queue. The resulting return value will also be provided to\nthe following function in the queue. If the return value is\nundefined, the previous return value will be retained.\n\n``` javascript\nnew Convergence()\n  // continues after finding a random even number\n  .when(() => {\n    let n = Math.ceil(Math.random() * 100)\n    return !(n % 2) && n\n  })\n  // multiplies the even number by another random number\n  .do((even) => {\n    return even * Math.ceil(Math.random() * 100)\n  })\n  // does not return, the previous value will be retained\n  .do((rand) => {\n    console.log('even number times random number = ', rand);\n  })\n  // asserts that any number times an even number is even\n  .always((rand) => {\n    let rand = Math.ceil(Math.random() * 100);\n    return !(rand % 2)\n  }, 100)\n```\n\nWhen a promise is returned from a callback, the convergence will\nwait for the promise to resolve before continuing.\n\n``` javascript\nnew Convergence()\n  .when(() => foo === 'bar')\n  .do(() => doSomethingAsync())\n  .do((baz) => console.log('resolved with', baz))\n```\n\nReturning other convergences from a callback is also\nsupported. The returned convergence will be run with the current\nremaining timeout. This is useful when computing convergences\nafter converging on another state.\n\n``` javascript\nnew Convergence()\n  // continue when `num` is less than 100\n  .when(() => num < 100)\n  .do(() => {\n    // if odd, wait until it is even\n    if (num % 2) {\n      return new Convergence()\n        .when(() => !(num % 2) && num)\n    } else {\n      return num;\n    }\n  })\n```",
    "params": [
      {
        "type": {
          "names": [
            "function"
          ]
        },
        "description": "The callback to execute",
        "name": "callback"
      }
    ],
    "returns": [
      {
        "type": {
          "names": [
            "Convergence"
          ]
        },
        "description": "A new convergence instance"
      }
    ],
    "name": "do",
    "longname": "Convergence#do",
    "kind": "function",
    "memberof": "Convergence",
    "scope": "instance"
  },
  {
    "comment": "/**\n   * Runs the current convergence instance, returning a promise that\n   * will resolve after all assertions have converged, or reject when\n   * any of them fail.\n   *\n   * ``` javascript\n   * let convergence = new Convergence().when(() => foo === 'bar');\n   *\n   * // will converge within the timeout or fail afterwards\n   * convegence.timeout(100).run()\n   *   .then(() => console.log('foo is bar!'))\n   *   .catch(() => console.log('foo is not bar'))\n   * ```\n   *\n   * When an assertion fails and the convergence rejects, it is\n   * rejected with the last error thrown from the assertion.\n   *\n   * ``` javascript\n   * let convergence = new Convergence().when(() => {\n   *   expect(foo).to.equal('bar')\n   * })\n   *\n   * // will fail after 100ms if `foo` does not equal `'bar'`\n   * convegence.timeout(100).run()\n   *   .catch((e) => console.error(e)) // expected '' to equal 'bar'\n   * ```\n   *\n   * When the convergence is successful and the promise resolves, it\n   * will resolve with a stats object containing useful information\n   * about how the convergence and it's assertions ran.\n   *\n   * ``` javascript\n   * let convergence = new Convergence()\n   *   .when(() => foo === 'bar')\n   *   .always(() => foo === 'bar')\n   *\n   * convergence.run().then((stats) => {\n   *   stats.start   // timestamp of the convergence start time\n   *   stats.end     // timestamp of the convergence end time\n   *   stats.elapsed // amount of milliseconds the convergence took\n   *   stats.timeout // the timeout this convergence used\n   *   stats.runs    // total times this convergence ran an assertion\n   *   stats.value   // last returned value from the queue\n   *   stats.queue   // array of other stats for each assertion\n   * })\n   * ```\n   *\n   * @returns {Promise}\n   */",
    "meta": {
      "range": [
        11746,
        12587
      ],
      "filename": "convergence.js",
      "lineno": 363,
      "columnno": 2,
      "path": "/src",
      "code": {
        "id": "astnode100000447",
        "name": "Convergence#run",
        "type": "MethodDefinition",
        "paramnames": []
      },
      "vars": {
        "": null
      }
    },
    "description": "Runs the current convergence instance, returning a promise that\nwill resolve after all assertions have converged, or reject when\nany of them fail.\n\n``` javascript\nlet convergence = new Convergence().when(() => foo === 'bar');\n\n// will converge within the timeout or fail afterwards\nconvegence.timeout(100).run()\n  .then(() => console.log('foo is bar!'))\n  .catch(() => console.log('foo is not bar'))\n```\n\nWhen an assertion fails and the convergence rejects, it is\nrejected with the last error thrown from the assertion.\n\n``` javascript\nlet convergence = new Convergence().when(() => {\n  expect(foo).to.equal('bar')\n})\n\n// will fail after 100ms if `foo` does not equal `'bar'`\nconvegence.timeout(100).run()\n  .catch((e) => console.error(e)) // expected '' to equal 'bar'\n```\n\nWhen the convergence is successful and the promise resolves, it\nwill resolve with a stats object containing useful information\nabout how the convergence and it's assertions ran.\n\n``` javascript\nlet convergence = new Convergence()\n  .when(() => foo === 'bar')\n  .always(() => foo === 'bar')\n\nconvergence.run().then((stats) => {\n  stats.start   // timestamp of the convergence start time\n  stats.end     // timestamp of the convergence end time\n  stats.elapsed // amount of milliseconds the convergence took\n  stats.timeout // the timeout this convergence used\n  stats.runs    // total times this convergence ran an assertion\n  stats.value   // last returned value from the queue\n  stats.queue   // array of other stats for each assertion\n})\n```",
    "returns": [
      {
        "type": {
          "names": [
            "Promise"
          ]
        }
      }
    ],
    "name": "run",
    "longname": "Convergence#run",
    "kind": "function",
    "memberof": "Convergence",
    "scope": "instance",
    "params": []
  },
  {
    "comment": "/**\n   * By being thennable we can enable the usage of async/await syntax\n   * with convergences. This allows us to naturally chain convergences\n   * without calling `#run()`.\n   *\n   * ``` javascript\n   * async function click(selector) {\n   *   // will resolve when the element exists and gets clicked\n   *   await new Convergence()\n   *     .when(() => {\n   *       let $node = document.querySelector('.element')\n   *       return !!$node && $node\n   *     })\n   *     .do(($node) => {\n   *       $node.click()\n   *     })\n   * }\n   * ```\n   *\n   * The convergence thennable method immediately invokes `#run()` and\n   * resolves with the last returned value from the convergence's\n   * queue. This allows us to await for values from a convergence.\n   *\n   * ``` javascript\n   * let find = (selector) => new Convergence().when(() => {\n   *   let $node = document.querySelector('.element')\n   *   return !!$node && $node\n   * })\n   *\n   * async function fill(selector, value) {\n   *   let $node = await find(selector)\n   *   $node.value = value\n   * }\n   * ```\n   *\n   * @private\n   * @returns {Promise}\n   */",
    "meta": {
      "range": [
        13703,
        13924
      ],
      "filename": "convergence.js",
      "lineno": 433,
      "columnno": 2,
      "path": "/src",
      "code": {
        "id": "astnode100000555",
        "name": "Convergence#then",
        "type": "MethodDefinition",
        "paramnames": []
      },
      "vars": {
        "": null
      }
    },
    "description": "By being thennable we can enable the usage of async/await syntax\nwith convergences. This allows us to naturally chain convergences\nwithout calling `#run()`.\n\n``` javascript\nasync function click(selector) {\n  // will resolve when the element exists and gets clicked\n  await new Convergence()\n    .when(() => {\n      let $node = document.querySelector('.element')\n      return !!$node && $node\n    })\n    .do(($node) => {\n      $node.click()\n    })\n}\n```\n\nThe convergence thennable method immediately invokes `#run()` and\nresolves with the last returned value from the convergence's\nqueue. This allows us to await for values from a convergence.\n\n``` javascript\nlet find = (selector) => new Convergence().when(() => {\n  let $node = document.querySelector('.element')\n  return !!$node && $node\n})\n\nasync function fill(selector, value) {\n  let $node = await find(selector)\n  $node.value = value\n}\n```",
    "access": "private",
    "returns": [
      {
        "type": {
          "names": [
            "Promise"
          ]
        }
      }
    ],
    "name": "then",
    "longname": "Convergence#then",
    "kind": "function",
    "memberof": "Convergence",
    "scope": "instance",
    "params": []
  },
  {
    "comment": "/**\n   * Returns a new convergence instance with the given timeout,\n   * inheriting the current instance's assertions. If no timeout is\n   * given, returns the current timeout for this instance.\n   *\n   * ``` javascript\n   * let quick = new Convergence(100)\n   * let long = quick.timeout(5000)\n   *\n   * quick.timeout() // => 100\n   * long.timeout() // => 5000\n   * ```\n   *\n   * @param {Number} [timeout] - Timeout for the next convergence\n   * @returns {Number|Convergence} The current instance timeout or\n   * a new convergence instance\n   */",
    "meta": {
      "range": [
        4016,
        4177
      ],
      "filename": "convergence.js",
      "lineno": 134,
      "columnno": 2,
      "path": "/src",
      "code": {
        "id": "astnode100000342",
        "name": "Convergence#timeout",
        "type": "MethodDefinition",
        "paramnames": [
          "timeout"
        ]
      },
      "vars": {
        "": null
      }
    },
    "description": "Returns a new convergence instance with the given timeout,\ninheriting the current instance's assertions. If no timeout is\ngiven, returns the current timeout for this instance.\n\n``` javascript\nlet quick = new Convergence(100)\nlet long = quick.timeout(5000)\n\nquick.timeout() // => 100\nlong.timeout() // => 5000\n```",
    "params": [
      {
        "type": {
          "names": [
            "Number"
          ]
        },
        "optional": true,
        "description": "Timeout for the next convergence",
        "name": "timeout"
      }
    ],
    "returns": [
      {
        "type": {
          "names": [
            "Number",
            "Convergence"
          ]
        },
        "description": "The current instance timeout or\na new convergence instance"
      }
    ],
    "name": "timeout",
    "longname": "Convergence#timeout",
    "kind": "function",
    "memberof": "Convergence",
    "scope": "instance"
  },
  {
    "comment": "/**\n   * Returns a new convergence instance with an additional assertion.\n   * This assertion is run repeatedly until it passes within the\n   * timeout. If the assertion does not pass within the timeout, the\n   * convergence will fail.\n   *\n   * ``` javascript\n   * // would converge when `foo` equals `'bar'`\n   * let convergeFoo = new Convergence().when(() => foo === 'bar')\n   *\n   * // would converge when `foo` equals `'bar'` and then `'baz'`\n   * let convergeFooBar = convergeFoo.when(() => foo === 'baz')\n   * ```\n   *\n   * @param {Function} assertion - The assertion to converge on\n   * @returns {Convergence} A new convergence instance\n   */",
    "meta": {
      "range": [
        4834,
        4933
      ],
      "filename": "convergence.js",
      "lineno": 159,
      "columnno": 2,
      "path": "/src",
      "code": {
        "id": "astnode100000365",
        "name": "Convergence#when",
        "type": "MethodDefinition",
        "paramnames": [
          "assertion"
        ]
      },
      "vars": {
        "": null
      }
    },
    "description": "Returns a new convergence instance with an additional assertion.\nThis assertion is run repeatedly until it passes within the\ntimeout. If the assertion does not pass within the timeout, the\nconvergence will fail.\n\n``` javascript\n// would converge when `foo` equals `'bar'`\nlet convergeFoo = new Convergence().when(() => foo === 'bar')\n\n// would converge when `foo` equals `'bar'` and then `'baz'`\nlet convergeFooBar = convergeFoo.when(() => foo === 'baz')\n```",
    "params": [
      {
        "type": {
          "names": [
            "function"
          ]
        },
        "description": "The assertion to converge on",
        "name": "assertion"
      }
    ],
    "returns": [
      {
        "type": {
          "names": [
            "Convergence"
          ]
        },
        "description": "A new convergence instance"
      }
    ],
    "name": "when",
    "longname": "Convergence#when",
    "kind": "function",
    "memberof": "Convergence",
    "scope": "instance"
  },
  {
    "comment": "/**\n * Converges on an assertion by resolving when the given assertion\n * passes _throughout_ the timeout period. The assertion will run once\n * every 10ms and is considered to be passing when it does not error\n * or return false. If the assertion does not pass consistently\n * throughout the entire timeout period, it will reject the very first\n * time it encounters a failure.\n *\n * ```javascript\n * // simple boolean test\n * await always(() => total !== 100)\n *\n * // with chai assertions\n * await always(() => {\n *   expect(total).to.not.equal(100)\n *   expect(add(total, 1)).to.equal(101)\n * })\n * ```\n *\n * The `timeout` argument controls how long it will take for the\n * assertion to converge. By default, this is `200ms`.\n *\n * ```javascript\n * // will pass if `num` is less than `100` for 2 seconds\n * await always(() => num < 100, 2000)\n * ```\n *\n * Returns a thennable function that can be used as a callback where\n * libraries support async functions.\n *\n * ```javascript\n * // mocha's `it` supports async tests\n * it('stays foo for one second', always(() => {\n *   expect(foo).to.equal('foo');\n * }, 1000));\n * ```\n *\n * @function always\n * @param {Function} assertion - Assertion to converge with\n * @param {Number} [timeout=200] - Timeout in milliseconds\n * @returns {Function} thennable function that resolves when the\n * assertion converges\n */",
    "meta": {
      "filename": "converge.js",
      "lineno": 154,
      "columnno": 0,
      "path": "/src",
      "code": {}
    },
    "description": "Converges on an assertion by resolving when the given assertion\npasses _throughout_ the timeout period. The assertion will run once\nevery 10ms and is considered to be passing when it does not error\nor return false. If the assertion does not pass consistently\nthroughout the entire timeout period, it will reject the very first\ntime it encounters a failure.\n\n```javascript\n// simple boolean test\nawait always(() => total !== 100)\n\n// with chai assertions\nawait always(() => {\n  expect(total).to.not.equal(100)\n  expect(add(total, 1)).to.equal(101)\n})\n```\n\nThe `timeout` argument controls how long it will take for the\nassertion to converge. By default, this is `200ms`.\n\n```javascript\n// will pass if `num` is less than `100` for 2 seconds\nawait always(() => num < 100, 2000)\n```\n\nReturns a thennable function that can be used as a callback where\nlibraries support async functions.\n\n```javascript\n// mocha's `it` supports async tests\nit('stays foo for one second', always(() => {\n  expect(foo).to.equal('foo');\n}, 1000));\n```",
    "kind": "function",
    "name": "always",
    "params": [
      {
        "type": {
          "names": [
            "function"
          ]
        },
        "description": "Assertion to converge with",
        "name": "assertion"
      },
      {
        "type": {
          "names": [
            "Number"
          ]
        },
        "optional": true,
        "defaultvalue": 200,
        "description": "Timeout in milliseconds",
        "name": "timeout"
      }
    ],
    "returns": [
      {
        "type": {
          "names": [
            "function"
          ]
        },
        "description": "thennable function that resolves when the\nassertion converges"
      }
    ],
    "longname": "always",
    "scope": "global"
  },
  {
    "comment": "/**\n * Converges on an assertion by resolving when the given assertion\n * passes _within_ the timeout period. The assertion will run once\n * every 10ms and is considered to be passing when it does not error\n * or return false. If the assertion never passes within the timeout\n * period, then the promise will reject as soon as it can with the\n * last error it recieved.\n *\n * ```javascript\n * // simple boolean test\n * await when(() => total === 100)\n *\n * // with chai assertions\n * await when(() => {\n *   expect(total).to.equal(100)\n *   expect(add(total, 1)).to.equal(101)\n * })\n * ```\n *\n * The `timeout` argument controls how long the assertion is given to\n * converge within. By default, this is `2000ms`.\n *\n * ```javascript\n * // will fail if `num` is not `1` within 100ms\n * await when(() => num === 1, 100)\n * ```\n *\n * Returns a thennable function that can be used as a callback where\n * libraries support async functions.\n *\n * ```javascript\n * // mocha's `it` supports async tests\n * it('becomes bar within one second', when(() => {\n *   expect(foo).to.equal('bar');\n * }, 1000));\n * ```\n *\n * @function when\n * @param {Function} assertion - Assertion to converge on\n * @param {Number} [timeout=2000] - Timeout in milliseconds\n * @returns {Function} thennable function that resolves when the\n * assertion converges\n */",
    "meta": {
      "filename": "converge.js",
      "lineno": 107,
      "columnno": 0,
      "path": "/src",
      "code": {}
    },
    "description": "Converges on an assertion by resolving when the given assertion\npasses _within_ the timeout period. The assertion will run once\nevery 10ms and is considered to be passing when it does not error\nor return false. If the assertion never passes within the timeout\nperiod, then the promise will reject as soon as it can with the\nlast error it recieved.\n\n```javascript\n// simple boolean test\nawait when(() => total === 100)\n\n// with chai assertions\nawait when(() => {\n  expect(total).to.equal(100)\n  expect(add(total, 1)).to.equal(101)\n})\n```\n\nThe `timeout` argument controls how long the assertion is given to\nconverge within. By default, this is `2000ms`.\n\n```javascript\n// will fail if `num` is not `1` within 100ms\nawait when(() => num === 1, 100)\n```\n\nReturns a thennable function that can be used as a callback where\nlibraries support async functions.\n\n```javascript\n// mocha's `it` supports async tests\nit('becomes bar within one second', when(() => {\n  expect(foo).to.equal('bar');\n}, 1000));\n```",
    "kind": "function",
    "name": "when",
    "params": [
      {
        "type": {
          "names": [
            "function"
          ]
        },
        "description": "Assertion to converge on",
        "name": "assertion"
      },
      {
        "type": {
          "names": [
            "Number"
          ]
        },
        "optional": true,
        "defaultvalue": 2000,
        "description": "Timeout in milliseconds",
        "name": "timeout"
      }
    ],
    "returns": [
      {
        "type": {
          "names": [
            "function"
          ]
        },
        "description": "thennable function that resolves when the\nassertion converges"
      }
    ],
    "longname": "when",
    "scope": "global"
  }
]