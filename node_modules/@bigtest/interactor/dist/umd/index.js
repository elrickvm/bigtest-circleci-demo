(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  (factory((global.BigTest = global.BigTest || {}, global.BigTest.Interactor = {})));
}(this, (function (exports) { 'use strict';

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
  }

  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }

  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        writable: true,
        configurable: true
      }
    });
    if (superClass) _setPrototypeOf(subClass, superClass);
  }

  function _getPrototypeOf(o) {
    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
      return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf(o);
  }

  function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };

    return _setPrototypeOf(o, p);
  }

  function _objectWithoutPropertiesLoose(source, excluded) {
    if (source == null) return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;

    for (i = 0; i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      target[key] = source[key];
    }

    return target;
  }

  function _objectWithoutProperties(source, excluded) {
    if (source == null) return {};

    var target = _objectWithoutPropertiesLoose(source, excluded);

    var key, i;

    if (Object.getOwnPropertySymbols) {
      var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

      for (i = 0; i < sourceSymbolKeys.length; i++) {
        key = sourceSymbolKeys[i];
        if (excluded.indexOf(key) >= 0) continue;
        if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
        target[key] = source[key];
      }
    }

    return target;
  }

  function _assertThisInitialized(self) {
    if (self === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return self;
  }

  function _possibleConstructorReturn(self, call) {
    if (call && (typeof call === "object" || typeof call === "function")) {
      return call;
    }

    return _assertThisInitialized(self);
  }

  function _slicedToArray(arr, i) {
    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();
  }

  function _toConsumableArray(arr) {
    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();
  }

  function _arrayWithoutHoles(arr) {
    if (Array.isArray(arr)) {
      for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

      return arr2;
    }
  }

  function _arrayWithHoles(arr) {
    if (Array.isArray(arr)) return arr;
  }

  function _iterableToArray(iter) {
    if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter);
  }

  function _iterableToArrayLimit(arr, i) {
    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = undefined;

    try {
      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"] != null) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance");
  }

  function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance");
  }

  function _toPropertyKey(key) {
    if (typeof key === "symbol") {
      return key;
    } else {
      return String(key);
    }
  }

  function _typeof$1(obj) {
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof$1 = function (obj) {
        return typeof obj;
      };
    } else {
      _typeof$1 = function (obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
      };
    }

    return _typeof$1(obj);
  }

  function _classCallCheck$1(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperties$1(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass$1(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties$1(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties$1(Constructor, staticProps);
    return Constructor;
  }

  function _toConsumableArray$1(arr) {
    return _arrayWithoutHoles$1(arr) || _iterableToArray$1(arr) || _nonIterableSpread$1();
  }

  function _arrayWithoutHoles$1(arr) {
    if (Array.isArray(arr)) {
      for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

      return arr2;
    }
  }

  function _iterableToArray$1(iter) {
    if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter);
  }

  function _nonIterableSpread$1() {
    throw new TypeError("Invalid attempt to spread non-iterable instance");
  }

  function convergeOn(assertion, timeout, always) {
    var start = Date.now();
    var interval = 10;
    var stats = {
      start: start,
      runs: 0,
      end: start,
      elapsed: 0,
      always: always,
      timeout: timeout,
      value: undefined
    };
    return new Promise(function (resolve, reject) {
      (function loop() {
        stats.runs += 1;

        try {
          var results = assertion();

          if (results && typeof results.then === 'function') {
            throw new Error('convergent assertion encountered a async function or promise; ' + 'since convergent assertions can run multiple times, you should ' + 'avoid introducing side-effects inside of them');
          }

          var doLoop = Date.now() - start < timeout;

          if (always && doLoop) {
            setTimeout(loop, interval);
          } else if (results === false) {
            throw new Error('convergent assertion returned `false`');
          } else if (!always && !doLoop) {
            throw new Error('convergent assertion was successful, ' + "but exceeded the ".concat(timeout, "ms timeout"));
          } else {
            stats.end = Date.now();
            stats.elapsed = stats.end - start;
            stats.value = results;
            resolve(stats);
          }
        } catch (error) {
          var _doLoop = Date.now() - start < timeout;

          if (!always && _doLoop) {
            setTimeout(loop, interval);
          } else if (always || !_doLoop) {
            reject(error);
          }
        }
      })();
    });
  }

  function when(assertion) {
    var timeout = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2000;
    return convergeOn(assertion, timeout, false);
  }

  function always(assertion) {
    var timeout = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 200;
    return convergeOn(assertion, timeout, true);
  }

  function getElapsedSince(start, max) {
    var elapsed = Date.now() - start;

    if (elapsed >= max) {
      throw new Error("convergence exceeded the ".concat(max, "ms timeout"));
    }

    return elapsed;
  }

  function collectStats(accumulator, stats) {
    accumulator.runs += stats.runs;
    accumulator.elapsed += stats.elapsed;
    accumulator.end = stats.end;
    accumulator.value = stats.value;
    accumulator.queue.push(stats);
    return stats.value;
  }

  function isConvergence(obj) {
    return !!obj && _typeof$1(obj) === 'object' && '_queue' in obj && Array.isArray(obj._queue) && 'timeout' in obj && typeof obj.timeout === 'function' && 'run' in obj && typeof obj.run === 'function';
  }

  function runAssertion(subject, arg, stats) {
    var timeout = stats.timeout - getElapsedSince(stats.start, stats.timeout);
    var assertion = subject.assertion.bind(this, arg);
    var converge = subject.always ? always : when;

    if (subject.always && !subject.last) {
      if (subject.timeout) {
        timeout = Math.min(timeout, subject.timeout);
      } else {
        timeout = Math.max(stats.timeout / 10, 20);
      }
    }

    return converge(assertion, timeout).then(function (convergeStats) {
      return collectStats(stats, convergeStats);
    });
  }

  function runCallback(subject, arg, stats) {
    var start = Date.now();
    var result = subject.callback.call(this, arg);

    var collectExecStats = function collectExecStats(value) {
      return collectStats(stats, {
        start: start,
        runs: 1,
        end: Date.now(),
        elapsed: getElapsedSince(start, stats.timeout),
        value: value
      });
    };

    if (isConvergence(result)) {
      var timeout = stats.timeout - getElapsedSince(start, stats.timeout);

      if (!subject.last) {
        result = result.do(function (ret) {
          return ret;
        });
      }

      return result.timeout(timeout).run().then(function (convergeStats) {
        return collectStats(stats, convergeStats);
      });
    } else if (result && typeof result.then === 'function') {
      return result.then(collectExecStats);
    } else {
      return collectExecStats(result);
    }
  }

  var Convergence = function () {
    function Convergence() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var previous = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      _classCallCheck$1(this, Convergence);

      if (typeof options === 'number') {
        options = {
          timeout: options
        };
      }

      var _options = options,
          _options$timeout = _options.timeout,
          timeout = _options$timeout === void 0 ? previous._timeout || 2000 : _options$timeout,
          _options$_queue = _options._queue,
          _queue = _options$_queue === void 0 ? [] : _options$_queue;

      _queue = _toConsumableArray$1(previous._queue || []).concat(_toConsumableArray$1(_queue));
      Object.defineProperties(this, {
        _timeout: {
          value: timeout
        },
        _queue: {
          value: _queue
        }
      });
    }

    _createClass$1(Convergence, [{
      key: "timeout",
      value: function timeout(_timeout) {
        if (typeof _timeout !== 'undefined') {
          return new this.constructor(_timeout, this);
        } else {
          return this._timeout;
        }
      }
    }, {
      key: "when",
      value: function when(assertion) {
        return new this.constructor({
          _queue: [{
            assertion: assertion
          }]
        }, this);
      }
    }, {
      key: "once",
      value: function once() {
        console.warn('#once() has been deprecated in favor of #when()');
        return this.when.apply(this, arguments);
      }
    }, {
      key: "always",
      value: function always(assertion, timeout) {
        return new this.constructor({
          _queue: [{
            always: true,
            assertion: assertion,
            timeout: timeout
          }]
        }, this);
      }
    }, {
      key: "do",
      value: function _do(callback) {
        return new this.constructor({
          _queue: [{
            callback: callback
          }]
        }, this);
      }
    }, {
      key: "append",
      value: function append(convergence) {
        if (!isConvergence(convergence)) {
          throw new Error('.append() only works with convergence instances');
        }

        return new this.constructor({
          _queue: convergence._queue
        }, this);
      }
    }, {
      key: "run",
      value: function run() {
        var _this = this;

        var start = Date.now();
        var stats = {
          start: start,
          runs: 0,
          end: start,
          elapsed: 0,
          value: undefined,
          timeout: this._timeout,
          queue: []
        };
        return this._queue.reduce(function (promise, subject, i) {
          if (i === _this._queue.length - 1) {
            subject = Object.assign({
              last: true
            }, subject);
          }

          return promise.then(function (ret) {
            if (subject.assertion) {
              return runAssertion.call(_this, subject, ret, stats);
            } else if (subject.callback) {
              return runCallback.call(_this, subject, ret, stats);
            }
          });
        }, Promise.resolve()).then(function () {
          return stats;
        });
      }
    }, {
      key: "then",
      value: function then() {
        var promise = this.run().then(function (_ref) {
          var value = _ref.value;
          return value;
        });
        return promise.then.apply(promise, arguments);
      }
    }]);

    return Convergence;
  }();

  Convergence.isConvergence = isConvergence;

  function $(selector) {
    var $ctx = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : document;
    var $node = null;

    if (!$ctx || typeof $ctx.querySelector !== 'function') {
      throw new Error('unable to use the current context');
    }

    if (typeof selector === 'string') {
      try {
        $node = $ctx.querySelector(selector);
      } catch (e) {
        throw new SyntaxError("\"".concat(selector, "\" is not a valid selector"));
      }
    } else if (selector instanceof Element) {
      return selector;
    } else if (!selector) {
      return $ctx;
    }

    if (!$node) {
      throw new Error("unable to find \"".concat(selector, "\""));
    }

    return $node;
  }
  function $$(selector) {
    var $ctx = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : document;
    var nodes = [];

    if (!$ctx || typeof $ctx.querySelectorAll !== 'function') {
      throw new Error('unable to use the current context');
    }

    if (typeof selector === 'string') {
      try {
        nodes = [].slice.call($ctx.querySelectorAll(selector));
      } catch (e) {
        throw new SyntaxError("\"".concat(selector, "\" is not a valid selector"));
      }
    } else if (Symbol.iterator in Object(selector)) {
      nodes = [].slice.call(selector);
    }

    return nodes.filter(function ($node) {
      return $node instanceof Element;
    });
  }

  var assign = Object.assign,
      defineProperties = Object.defineProperties,
      entries = Object.entries,
      getPrototypeOf = Object.getPrototypeOf,
      getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors;

  function isSameType(a, b) {
    return a && b && getPrototypeOf(a) === getPrototypeOf(b);
  }

  function chainable(fn) {
    return function () {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      var results = fn.apply(this.only(), args);

      if (isSameType(this, results && results.__parent__)) {
        results = new results.constructor({
          parent: this
        }, results);
      }

      if (isSameType(this, results)) {
        results = this.__parent__.append(results);
      }

      return results;
    };
  }

  function getAllDescriptors(instance) {
    var proto = instance;
    var descr = {};

    while (proto && proto !== Object.prototype) {
      descr = assign({}, getOwnPropertyDescriptors(proto), descr);
      proto = getPrototypeOf(proto);
    }

    return descr;
  }

  function makeParentChainable(instance) {
    defineProperties(instance, entries(getAllDescriptors(instance)).reduce(function (acc, _ref) {
      var _ref2 = _slicedToArray(_ref, 2),
          key = _ref2[0],
          descriptor = _ref2[1];

      var value = descriptor.value,
          get = descriptor.get;

      if (key === 'constructor' || descriptor.configurable === false) {
        return acc;
      }

      if (typeof value === 'function') {
        assign(descriptor, {
          value: chainable(value)
        });
      } else if (typeof get === 'function') {
        assign(descriptor, {
          get: chainable(get)
        });
      }

      return assign(acc, _defineProperty({}, key, descriptor));
    }, {
      only: {
        value: function value() {
          return new instance.constructor({
            parent: null
          }, instance);
        }
      }
    }));
  }

  function isInteractor(obj) {
    return isConvergence(obj) && '$' in obj && typeof obj.$ === 'function' && '$$' in obj && typeof obj.$$ === 'function' && '$root' in obj;
  }

  var assign$1 = Object.assign,
      getOwnPropertyDescriptors$1 = Object.getOwnPropertyDescriptors,
      getPrototypeOf$1 = Object.getPrototypeOf;

  function omit(obj, key) {
    var _ = obj[key],
        rest = _objectWithoutProperties(obj, [key].map(_toPropertyKey));

    return rest;
  }

  function extend(classDescriptor) {
    var _this = this;

    if (classDescriptor.kind === 'class') {
      var kind = classDescriptor.kind,
          elements = classDescriptor.elements;
      return {
        kind: kind,
        finisher: function finisher(constructor) {
          return _this.from(elements.reduce(function (acc, el) {
            return assign$1(_defineProperty({}, el.key, el.placement === 'own' ? el.initializer() : el.descriptor), acc);
          }, {
            static: assign$1({
              name: constructor.name
            }, constructor)
          }));
        }
      };
    } else if (typeof classDescriptor === 'function') {
      var _constructor = classDescriptor;
      return this.from(assign$1({}, new _constructor(), omit(getOwnPropertyDescriptors$1(_constructor.prototype), 'constructor'), {
        static: assign$1({
          name: _constructor.name
        }, _constructor)
      }));
    } else if (getPrototypeOf$1(classDescriptor) === Object.prototype) {
      console.warn("Deprecated usage of decorator with plain objects. Use `".concat(this.name, ".from` instead."));
      return this.from(classDescriptor);
    }
  }

  var assign$2 = Object.assign,
      defineProperties$1 = Object.defineProperties,
      entries$1 = Object.entries,
      getOwnPropertyDescriptors$2 = Object.getOwnPropertyDescriptors,
      getOwnPropertyNames = Object.getOwnPropertyNames,
      hasOwnProperty = Object.hasOwnProperty;

  function checkForReservedPropertyNames(obj) {
    var blacklist = ['$', '$$', '$root', 'only', '__parent__'].concat(_toConsumableArray(getOwnPropertyNames(Convergence.prototype)));
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = getOwnPropertyNames(obj)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var key = _step.value;

        if (blacklist.includes(key)) {
          throw new Error("\"".concat(key, "\" is a reserved property name"));
        }
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return != null) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    return obj;
  }

  function isPropertyDescriptor(obj) {
    return obj && (hasOwnProperty.call(obj, 'get') || hasOwnProperty.call(obj, 'value'));
  }

  function toInteractorDescriptor(from) {
    if (isPropertyDescriptor(from)) {
      return from;
    } else if (isInteractor(from)) {
      return {
        get: function get() {
          return new from.constructor({
            parent: this
          }, from);
        }
      };
    } else {
      return {
        value: from
      };
    }
  }

  function from(properties) {
    var CustomInteractor = function (_this) {
      _inherits(CustomInteractor, _this);

      function CustomInteractor() {
        _classCallCheck(this, CustomInteractor);

        return _possibleConstructorReturn(this, _getPrototypeOf(CustomInteractor).apply(this, arguments));
      }

      return CustomInteractor;
    }(this);
    defineProperties$1(CustomInteractor.prototype, checkForReservedPropertyNames(entries$1(getOwnPropertyDescriptors$2(properties)).reduce(function (acc, _ref) {
      var _ref2 = _slicedToArray(_ref, 2),
          key = _ref2[0],
          descr = _ref2[1];

      return assign$2(acc, _defineProperty({}, key, hasOwnProperty.call(descr, 'value') ? toInteractorDescriptor(descr.value) : descr));
    }, {})));

    if (properties.static) {
      defineProperties$1(CustomInteractor, getOwnPropertyDescriptors$2(properties.static));
    }

    return CustomInteractor;
  }

  function computed(getter) {
    return Object.assign({
      enumerable: false,
      configurable: false,
      get: getter
    });
  }
  function action(method) {
    return Object.assign({
      enumerable: false,
      configurable: false,
      value: method
    });
  }

  function find(selector) {
    var _this = this;

    return this.when(function () {
      return _this.$(selector);
    });
  }
  function find$1 (selector) {
    return computed(function () {
      return this.$(selector);
    });
  }

  function findAll(selector) {
    var _this = this;

    return this.when(function () {
      return _this.$$(selector);
    });
  }
  function findAll$1 (selector) {
    return computed(function () {
      return this.$$(selector);
    });
  }

  function scoped(selector) {
    var _this = this;

    var properties = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var ScopedInteractor = properties.prototype instanceof Interactor ? properties : Interactor.from(properties);
    return new ScopedInteractor({
      scope: function scope() {
        return _this.$(selector);
      },
      parent: this
    });
  }
  function scoped$1 (selector) {
    var descriptors = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    return computed(function () {
      return scoped.call(this, selector, descriptors);
    });
  }

  function click(selector) {
    return find.call(this, selector).do(function ($node) {
      return $node.click();
    });
  }
  function clickable (selector) {
    return action(function () {
      return click.call(this, selector);
    });
  }

  function fill(selectorOrValue, value) {
    var selector;

    if (typeof value === 'undefined') {
      value = selectorOrValue;
    } else {
      selector = selectorOrValue;
    }

    return find.call(this, selector).do(function ($node) {
      var descriptor = Object.getOwnPropertyDescriptor($node, 'value');
      if (descriptor) delete $node.value;
      $node.value = value;
      $node.dispatchEvent(new Event('input', {
        bubbles: true,
        cancelable: true
      }));
      $node.dispatchEvent(new Event('change', {
        bubbles: true,
        cancelable: true
      }));

      if (descriptor) {
        Object.defineProperty($node, 'value', descriptor);
      }
    });
  }
  function fillable (selector) {
    return action(function (value) {
      return fill.call(this, selector, value);
    });
  }

  function select(selectorOrOption, options) {
    var selector;

    if (typeof options === 'undefined') {
      options = selectorOrOption;
    } else {
      selector = selectorOrOption;
    }

    options = [].concat(options);
    return find.call(this, selector).when(function ($select) {
      if (!$select.multiple && options.length > 1) {
        throw new Error("unable to select more than one option for \"".concat(selector, "\""));
      }

      return [$select, options.map(function (option) {
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = $select.options[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var $option = _step.value;

            if ($option.text === option) {
              return $option;
            }
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator.return != null) {
              _iterator.return();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }

        throw new Error("unable to find option \"".concat(option, "\""));
      })];
    }).do(function (_ref) {
      var _ref2 = _slicedToArray(_ref, 2),
          $select = _ref2[0],
          $options = _ref2[1];

      if ($select.multiple) {
        $options.forEach(function (option) {
          option.selected = !option.selected;
        });
      } else {
        $options[0].selected = true;
      }

      $select.dispatchEvent(new Event('input', {
        bubbles: true,
        cancelable: true
      }));
      $select.dispatchEvent(new Event('change', {
        bubbles: true,
        cancelable: true
      }));
    });
  }
  function selectable (selector) {
    return action(function (option) {
      return select.call(this, selector, option);
    });
  }

  function focus(selector) {
    return find.call(this, selector).do(function ($node) {
      $node.focus();
    });
  }
  function focusable (selector) {
    return action(function () {
      return focus.call(this, selector);
    });
  }

  function blur(selector) {
    return find.call(this, selector).do(function ($node) {
      $node.blur();
    });
  }
  function blurrable (selector) {
    return action(function () {
      return blur.call(this, selector);
    });
  }

  function getTriggerArgs(args) {
    var selector, eventName, options;

    if (args.length === 3) {
      var _args = _slicedToArray(args, 3);

      selector = _args[0];
      eventName = _args[1];
      options = _args[2];
    } else if (args.length === 2) {
      if (typeof args[1] === 'string') {
        var _args2 = _slicedToArray(args, 2);

        selector = _args2[0];
        eventName = _args2[1];
      } else {
        var _args3 = _slicedToArray(args, 2);

        eventName = _args3[0];
        options = _args3[1];
      }
    } else {
      var _args4 = _slicedToArray(args, 1);

      eventName = _args4[0];
    }

    return [selector, eventName, options];
  }

  function trigger() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var _getTriggerArgs = getTriggerArgs(args),
        _getTriggerArgs2 = _slicedToArray(_getTriggerArgs, 3),
        selector = _getTriggerArgs2[0],
        eventName = _getTriggerArgs2[1],
        _getTriggerArgs2$ = _getTriggerArgs2[2],
        options = _getTriggerArgs2$ === void 0 ? {} : _getTriggerArgs2$;

    return find.call(this, selector).do(function ($node) {
      var bubbles = 'bubbles' in options ? options.bubbles : true;
      var cancelable = 'cancelable' in options ? options.cancelable : true;
      delete options.bubbles;
      delete options.cancelable;
      var event = new Event(eventName, {
        bubbles: bubbles,
        cancelable: cancelable
      });
      Object.assign(event, options);
      $node.dispatchEvent(event);
    });
  }
  function triggerable () {
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }

    var _getTriggerArgs3 = getTriggerArgs(args),
        _getTriggerArgs4 = _slicedToArray(_getTriggerArgs3, 3),
        selector = _getTriggerArgs4[0],
        eventName = _getTriggerArgs4[1],
        _getTriggerArgs4$ = _getTriggerArgs4[2],
        options = _getTriggerArgs4$ === void 0 ? {} : _getTriggerArgs4$;

    return action(function (opts) {
      opts = Object.assign({}, options, opts);
      return trigger.call(this, selector, eventName, opts);
    });
  }

  function scroll(selectorOrScrollTo, scrollTo) {
    var selector;

    if (typeof scrollTo === 'undefined') {
      scrollTo = selectorOrScrollTo;
    } else {
      selector = selectorOrScrollTo;
    }

    return find.call(this, selector).do(function ($node) {
      if (typeof scrollTo.left === 'number') {
        $node.scrollLeft = scrollTo.left;
      }

      if (typeof scrollTo.top === 'number') {
        $node.scrollTop = scrollTo.top;
      }

      $node.dispatchEvent(new Event('scroll', {
        bubbles: true,
        cancelable: true
      }));
    });
  }
  function scrollable (selector) {
    return action(function (scrollTo) {
      return scroll.call(this, selector, scrollTo);
    });
  }

  function getText($el) {
    return $el.textContent.replace(/[\n\r]+/g, ' ').replace(/\s{2,}/g, ' ').trim();
  }

  function text() {
    return getText(this.$root);
  }
  function text$1 (selector) {
    return computed(function () {
      return getText(this.$(selector));
    });
  }

  function value() {
    return this.$root.value;
  }
  function value$1 (selector) {
    return computed(function () {
      return this.$(selector).value;
    });
  }

  function isVisible() {
    return !!this.$root.getClientRects().length;
  }
  function isVisible$1 (selector) {
    return computed(function () {
      return !!this.$(selector).getClientRects().length;
    });
  }

  function isHidden() {
    return !this.$root.getClientRects().length;
  }
  function isHidden$1 (selector) {
    return computed(function () {
      return !this.$(selector).getClientRects().length;
    });
  }

  function isPresent() {
    try {
      return !!this.$root;
    } catch (e) {
      return false;
    }
  }
  function isPresent$1 (selector) {
    return computed(function () {
      return this.isPresent && !!this.$$(selector).length;
    });
  }

  var assign$3 = Object.assign,
      entries$2 = Object.entries,
      defineProperties$2 = Object.defineProperties,
      getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

  var Interactor = function (_Convergence) {
    _inherits(Interactor, _Convergence);

    function Interactor() {
      var _this;

      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var previous = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      _classCallCheck(this, Interactor);

      if (typeof options === 'string' || options instanceof Element || typeof options === 'function') {
        options = {
          scope: options
        };
      }

      _this = _possibleConstructorReturn(this, _getPrototypeOf(Interactor).call(this, options, previous));
      var _options = options,
          _options$parent = _options.parent,
          parent = _options$parent === void 0 ? previous.__parent__ : _options$parent,
          _options$scope = _options.scope,
          scope = _options$scope === void 0 ? _this.constructor.defaultScope : _options$scope;
      defineProperties$2(_assertThisInitialized(_assertThisInitialized(_this)), {
        __parent__: {
          value: parent
        },
        $root: getOwnPropertyDescriptor(previous, '$root') || {
          get: function get() {
            return $(typeof scope === 'function' ? scope() : scope);
          }
        }
      });

      if (parent) {
        makeParentChainable(_assertThisInitialized(_assertThisInitialized(_this)));
      }

      return _this;
    }

    _createClass(Interactor, [{
      key: "$",
      value: function $$$1(selector) {
        return $(selector, this.$root);
      }
    }, {
      key: "$$",
      value: function $$$$1(selector) {
        return $$(selector, this.$root);
      }
    }, {
      key: "pause",
      value: function pause() {
        console.warn("Using `#pause()` is deprecated.\nIt is a hack that prevents the current event loop from running, and can cause some browsers or processes to hang.");
        return this.do(function () {
          return new Promise(function () {});
        });
      }
    }]);

    return Interactor;
  }(Convergence);

  defineProperties$2(Interactor, {
    isInteractor: {
      value: isInteractor
    },
    extend: {
      get: function get() {
        return extend.bind(this);
      }
    },
    from: {
      get: function get() {
        return from.bind(this);
      }
    },
    defaultScope: {
      value: document.body
    }
  });
  defineProperties$2(Interactor.prototype, entries$2({
    find: find,
    findAll: findAll,
    scoped: scoped,
    click: click,
    fill: fill,
    select: select,
    focus: focus,
    blur: blur,
    trigger: trigger,
    scroll: scroll
  }).reduce(function (descriptors, _ref) {
    var _ref2 = _slicedToArray(_ref, 2),
        name = _ref2[0],
        method = _ref2[1];

    return assign$3(descriptors, _defineProperty({}, name, {
      value: method
    }));
  }, {}));
  defineProperties$2(Interactor.prototype, entries$2({
    text: text,
    value: value,
    isVisible: isVisible,
    isHidden: isHidden,
    isPresent: isPresent
  }).reduce(function (descriptors, _ref3) {
    var _ref4 = _slicedToArray(_ref3, 2),
        name = _ref4[0],
        getter = _ref4[1];

    return assign$3(descriptors, _defineProperty({}, name, {
      get: getter
    }));
  }, {}));

  function interactor(classDescriptor) {
    return Interactor.extend(classDescriptor);
  }

  function collection (selector) {
    var properties = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var _scope = selector;

    if (typeof selector === 'string') {
      _scope = function scope(index) {
        if (typeof index === 'number') {
          var items = this.$$(selector);

          if (!items[index]) {
            throw new Error("unable to find \"".concat(selector, "\" at index ").concat(index));
          }

          return items[index];
        } else {
          return selector;
        }
      };
    }

    return action(function () {
      var _this = this;

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      var ItemInteractor = properties.prototype instanceof Interactor ? properties : Interactor.from(properties);

      if (args.length) {
        return new ItemInteractor({
          scope: function scope() {
            return _scope.apply(_this, args);
          },
          parent: this
        });
      } else {
        return this.$$(_scope.call(this)).map(function (item) {
          return new ItemInteractor(item);
        });
      }
    });
  }

  function count (selector) {
    return computed(function () {
      return this.$$(selector).length;
    });
  }

  function attribute (selector, attr) {
    if (!attr) {
      attr = selector;
      selector = null;
    }

    return computed(function () {
      return this.$(selector).getAttribute(attr);
    });
  }

  function property (selector, prop) {
    if (!prop) {
      prop = selector;
      selector = null;
    }

    return computed(function () {
      return this.$(selector)[prop];
    });
  }

  function hasClass (selector, className) {
    if (!className) {
      className = selector;
      selector = null;
    }

    return computed(function () {
      return this.$(selector).classList.contains(className);
    });
  }

  function elementMatches($el, selector) {
    if (!$el.matches) {
      return $el.msMatchesSelector(selector);
    } else {
      return $el.matches(selector);
    }
  }

  function is (selector, match) {
    if (!match) {
      match = selector;
      selector = null;
    }

    return computed(function () {
      return elementMatches(this.$(selector), match);
    });
  }

  exports.default = Interactor;
  exports.Interactor = Interactor;
  exports.interactor = interactor;
  exports.clickable = clickable;
  exports.fillable = fillable;
  exports.selectable = selectable;
  exports.focusable = focusable;
  exports.blurrable = blurrable;
  exports.triggerable = triggerable;
  exports.scrollable = scrollable;
  exports.collection = collection;
  exports.scoped = scoped$1;
  exports.find = find$1;
  exports.findAll = findAll$1;
  exports.count = count;
  exports.text = text$1;
  exports.value = value$1;
  exports.attribute = attribute;
  exports.property = property;
  exports.hasClass = hasClass;
  exports.is = is;
  exports.isVisible = isVisible$1;
  exports.isHidden = isHidden$1;
  exports.isPresent = isPresent$1;
  exports.computed = computed;
  exports.action = action;

  Object.defineProperty(exports, '__esModule', { value: true });

})));
