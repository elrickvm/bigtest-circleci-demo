(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('react'), require('react-dom')) :
  typeof define === 'function' && define.amd ? define(['exports', 'react', 'react-dom'], factory) :
  (factory((global.BigTest = global.BigTest || {}, global.BigTest.ReactHelpers = {}),global.React,global.ReactDOM));
}(this, (function (exports,React,reactDom) { 'use strict';

  React = React && React.hasOwnProperty('default') ? React['default'] : React;

  function _typeof(obj) {
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof = function (obj) {
        return typeof obj;
      };
    } else {
      _typeof = function (obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
      };
    }

    return _typeof(obj);
  }

  function _objectWithoutProperties(source, excluded) {
    if (source == null) return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;

    for (i = 0; i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      target[key] = source[key];
    }

    if (Object.getOwnPropertySymbols) {
      var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

      for (i = 0; i < sourceSymbolKeys.length; i++) {
        key = sourceSymbolKeys[i];
        if (excluded.indexOf(key) >= 0) continue;
        if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
        target[key] = source[key];
      }
    }

    return target;
  }

  var context = Object.create(null);
  function clearContext() {
    context = Object.create(null);
  }
  function setContext(newContext) {
    Object.assign(context, newContext);
  }
  function getContext(key, error) {
    if (typeof error === 'undefined') {
      error = "no ".concat(key, " context, make sure `setupAppForTesting` was called");
    }

    if (key in context) {
      return context[key];
    } else if (error) {
      throw new Error(error);
    }
  }

  function insertNode(id, $root) {
    var $node = document.createElement('div');
    $node.id = id;
    $root.appendChild($node);
    return $node;
  }

  function cleanup() {
    var _ref = getContext('mountOptions', false) || {},
        node = _ref.node,
        _ref$teardown = _ref.teardown,
        teardown = _ref$teardown === void 0 ? function () {} : _ref$teardown;

    return Promise.resolve().then(teardown).then(function () {
      if (node) {
        reactDom.unmountComponentAtNode(node);
        node.parentNode.removeChild(node);
      }

      clearContext();
    });
  }
  function mount(Component) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var _options$mountId = options.mountId,
        mountId = _options$mountId === void 0 ? 'testing-root' : _options$mountId,
        _options$rootElement = options.rootElement,
        rootElement = _options$rootElement === void 0 ? document.body : _options$rootElement,
        _options$setup = options.setup,
        setup = _options$setup === void 0 ? function () {} : _options$setup,
        teardown = options.teardown;
    return cleanup().then(setup).then(function () {
      return new Promise(function (resolve) {
        var node = insertNode(mountId, rootElement);
        setContext({
          mountOptions: {
            node: node,
            teardown: teardown
          }
        });
        reactDom.render(React.createElement(Component, null), node, resolve);
      });
    });
  }

  function unwrapExports (x) {
  	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
  }

  function createCommonjsModule(fn, module) {
  	return module = { exports: {} }, fn(module, module.exports), module.exports;
  }

  var __DEV__ = process.env.NODE_ENV !== 'production';

  var warning = function warning() {};

  if (__DEV__) {
    warning = function warning(condition, format, args) {
      var len = arguments.length;
      args = new Array(len > 2 ? len - 2 : 0);

      for (var key = 2; key < len; key++) {
        args[key - 2] = arguments[key];
      }

      if (format === undefined) {
        throw new Error('`warning(condition, format, ...args)` requires a warning ' + 'message argument');
      }

      if (format.length < 10 || /^[s\W]*$/.test(format)) {
        throw new Error('The warning format should be able to uniquely identify this ' + 'warning. Please, use a more descriptive format than: ' + format);
      }

      if (!condition) {
        var argIndex = 0;
        var message = 'Warning: ' + format.replace(/%s/g, function () {
          return args[argIndex++];
        });

        if (typeof console !== 'undefined') {
          console.error(message);
        }

        try {
          throw new Error(message);
        } catch (x) {}
      }
    };
  }

  var warning_1 = warning;

  var PathUtils = createCommonjsModule(function (module, exports) {

    exports.__esModule = true;

    var addLeadingSlash = exports.addLeadingSlash = function addLeadingSlash(path) {
      return path.charAt(0) === '/' ? path : '/' + path;
    };

    var stripLeadingSlash = exports.stripLeadingSlash = function stripLeadingSlash(path) {
      return path.charAt(0) === '/' ? path.substr(1) : path;
    };

    var hasBasename = exports.hasBasename = function hasBasename(path, prefix) {
      return new RegExp('^' + prefix + '(\\/|\\?|#|$)', 'i').test(path);
    };

    var stripBasename = exports.stripBasename = function stripBasename(path, prefix) {
      return hasBasename(path, prefix) ? path.substr(prefix.length) : path;
    };

    var stripTrailingSlash = exports.stripTrailingSlash = function stripTrailingSlash(path) {
      return path.charAt(path.length - 1) === '/' ? path.slice(0, -1) : path;
    };

    var parsePath = exports.parsePath = function parsePath(path) {
      var pathname = path || '/';
      var search = '';
      var hash = '';
      var hashIndex = pathname.indexOf('#');

      if (hashIndex !== -1) {
        hash = pathname.substr(hashIndex);
        pathname = pathname.substr(0, hashIndex);
      }

      var searchIndex = pathname.indexOf('?');

      if (searchIndex !== -1) {
        search = pathname.substr(searchIndex);
        pathname = pathname.substr(0, searchIndex);
      }

      return {
        pathname: pathname,
        search: search === '?' ? '' : search,
        hash: hash === '#' ? '' : hash
      };
    };

    var createPath = exports.createPath = function createPath(location) {
      var pathname = location.pathname,
          search = location.search,
          hash = location.hash;
      var path = pathname || '/';
      if (search && search !== '?') path += search.charAt(0) === '?' ? search : '?' + search;
      if (hash && hash !== '#') path += hash.charAt(0) === '#' ? hash : '#' + hash;
      return path;
    };
  });
  unwrapExports(PathUtils);
  var PathUtils_1 = PathUtils.addLeadingSlash;
  var PathUtils_2 = PathUtils.stripLeadingSlash;
  var PathUtils_3 = PathUtils.hasBasename;
  var PathUtils_4 = PathUtils.stripBasename;
  var PathUtils_5 = PathUtils.stripTrailingSlash;
  var PathUtils_6 = PathUtils.parsePath;
  var PathUtils_7 = PathUtils.createPath;

  function isAbsolute(pathname) {
    return pathname.charAt(0) === '/';
  }

  function spliceOne(list, index) {
    for (var i = index, k = i + 1, n = list.length; k < n; i += 1, k += 1) {
      list[i] = list[k];
    }

    list.pop();
  }

  function resolvePathname(to) {
    var from = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
    var toParts = to && to.split('/') || [];
    var fromParts = from && from.split('/') || [];
    var isToAbs = to && isAbsolute(to);
    var isFromAbs = from && isAbsolute(from);
    var mustEndAbs = isToAbs || isFromAbs;

    if (to && isAbsolute(to)) {
      fromParts = toParts;
    } else if (toParts.length) {
      fromParts.pop();
      fromParts = fromParts.concat(toParts);
    }

    if (!fromParts.length) return '/';
    var hasTrailingSlash = void 0;

    if (fromParts.length) {
      var last = fromParts[fromParts.length - 1];
      hasTrailingSlash = last === '.' || last === '..' || last === '';
    } else {
      hasTrailingSlash = false;
    }

    var up = 0;

    for (var i = fromParts.length; i >= 0; i--) {
      var part = fromParts[i];

      if (part === '.') {
        spliceOne(fromParts, i);
      } else if (part === '..') {
        spliceOne(fromParts, i);
        up++;
      } else if (up) {
        spliceOne(fromParts, i);
        up--;
      }
    }

    if (!mustEndAbs) for (; up--; up) {
      fromParts.unshift('..');
    }
    if (mustEndAbs && fromParts[0] !== '' && (!fromParts[0] || !isAbsolute(fromParts[0]))) fromParts.unshift('');
    var result = fromParts.join('/');
    if (hasTrailingSlash && result.substr(-1) !== '/') result += '/';
    return result;
  }

  var resolvePathname$1 = /*#__PURE__*/Object.freeze({
    default: resolvePathname
  });

  var _typeof$1 = typeof Symbol === "function" && _typeof(Symbol.iterator) === "symbol" ? function (obj) {
    return _typeof(obj);
  } : function (obj) {
    return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : _typeof(obj);
  };

  function valueEqual(a, b) {
    if (a === b) return true;
    if (a == null || b == null) return false;

    if (Array.isArray(a)) {
      return Array.isArray(b) && a.length === b.length && a.every(function (item, index) {
        return valueEqual(item, b[index]);
      });
    }

    var aType = typeof a === 'undefined' ? 'undefined' : _typeof$1(a);
    var bType = typeof b === 'undefined' ? 'undefined' : _typeof$1(b);
    if (aType !== bType) return false;

    if (aType === 'object') {
      var aValue = a.valueOf();
      var bValue = b.valueOf();
      if (aValue !== a || bValue !== b) return valueEqual(aValue, bValue);
      var aKeys = Object.keys(a);
      var bKeys = Object.keys(b);
      if (aKeys.length !== bKeys.length) return false;
      return aKeys.every(function (key) {
        return valueEqual(a[key], b[key]);
      });
    }

    return false;
  }

  var valueEqual$1 = /*#__PURE__*/Object.freeze({
    default: valueEqual
  });

  var _resolvePathname = ( resolvePathname$1 && resolvePathname ) || resolvePathname$1;

  var _valueEqual = ( valueEqual$1 && valueEqual ) || valueEqual$1;

  var LocationUtils = createCommonjsModule(function (module, exports) {

    exports.__esModule = true;
    exports.locationsAreEqual = exports.createLocation = undefined;

    var _extends$$1 = Object.assign || function (target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];

        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }

      return target;
    };

    var _resolvePathname2 = _interopRequireDefault$$1(_resolvePathname);

    var _valueEqual2 = _interopRequireDefault$$1(_valueEqual);

    function _interopRequireDefault$$1(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }

    var createLocation = exports.createLocation = function createLocation(path, state, key, currentLocation) {
      var location = void 0;

      if (typeof path === 'string') {
        location = (0, PathUtils.parsePath)(path);
        location.state = state;
      } else {
        location = _extends$$1({}, path);
        if (location.pathname === undefined) location.pathname = '';

        if (location.search) {
          if (location.search.charAt(0) !== '?') location.search = '?' + location.search;
        } else {
          location.search = '';
        }

        if (location.hash) {
          if (location.hash.charAt(0) !== '#') location.hash = '#' + location.hash;
        } else {
          location.hash = '';
        }

        if (state !== undefined && location.state === undefined) location.state = state;
      }

      try {
        location.pathname = decodeURI(location.pathname);
      } catch (e) {
        if (e instanceof URIError) {
          throw new URIError('Pathname "' + location.pathname + '" could not be decoded. ' + 'This is likely caused by an invalid percent-encoding.');
        } else {
          throw e;
        }
      }

      if (key) location.key = key;

      if (currentLocation) {
        if (!location.pathname) {
          location.pathname = currentLocation.pathname;
        } else if (location.pathname.charAt(0) !== '/') {
          location.pathname = (0, _resolvePathname2.default)(location.pathname, currentLocation.pathname);
        }
      } else {
        if (!location.pathname) {
          location.pathname = '/';
        }
      }

      return location;
    };

    var locationsAreEqual = exports.locationsAreEqual = function locationsAreEqual(a, b) {
      return a.pathname === b.pathname && a.search === b.search && a.hash === b.hash && a.key === b.key && (0, _valueEqual2.default)(a.state, b.state);
    };
  });
  unwrapExports(LocationUtils);
  var LocationUtils_1 = LocationUtils.locationsAreEqual;
  var LocationUtils_2 = LocationUtils.createLocation;

  var createTransitionManager_1 = createCommonjsModule(function (module, exports) {

    exports.__esModule = true;

    var _warning2 = _interopRequireDefault$$1(warning_1);

    function _interopRequireDefault$$1(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }

    var createTransitionManager = function createTransitionManager() {
      var prompt = null;

      var setPrompt = function setPrompt(nextPrompt) {
        (0, _warning2.default)(prompt == null, 'A history supports only one prompt at a time');
        prompt = nextPrompt;
        return function () {
          if (prompt === nextPrompt) prompt = null;
        };
      };

      var confirmTransitionTo = function confirmTransitionTo(location, action, getUserConfirmation, callback) {
        if (prompt != null) {
          var result = typeof prompt === 'function' ? prompt(location, action) : prompt;

          if (typeof result === 'string') {
            if (typeof getUserConfirmation === 'function') {
              getUserConfirmation(result, callback);
            } else {
              (0, _warning2.default)(false, 'A history needs a getUserConfirmation function in order to use a prompt message');
              callback(true);
            }
          } else {
            callback(result !== false);
          }
        } else {
          callback(true);
        }
      };

      var listeners = [];

      var appendListener = function appendListener(fn) {
        var isActive = true;

        var listener = function listener() {
          if (isActive) fn.apply(undefined, arguments);
        };

        listeners.push(listener);
        return function () {
          isActive = false;
          listeners = listeners.filter(function (item) {
            return item !== listener;
          });
        };
      };

      var notifyListeners = function notifyListeners() {
        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        listeners.forEach(function (listener) {
          return listener.apply(undefined, args);
        });
      };

      return {
        setPrompt: setPrompt,
        confirmTransitionTo: confirmTransitionTo,
        appendListener: appendListener,
        notifyListeners: notifyListeners
      };
    };

    exports.default = createTransitionManager;
  });
  unwrapExports(createTransitionManager_1);

  var createMemoryHistory_1 = createCommonjsModule(function (module, exports) {

    exports.__esModule = true;

    var _typeof$$1 = typeof Symbol === "function" && _typeof(Symbol.iterator) === "symbol" ? function (obj) {
      return _typeof(obj);
    } : function (obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : _typeof(obj);
    };

    var _extends$$1 = Object.assign || function (target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];

        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }

      return target;
    };

    var _warning2 = _interopRequireDefault$$1(warning_1);

    var _createTransitionManager2 = _interopRequireDefault$$1(createTransitionManager_1);

    function _interopRequireDefault$$1(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }

    var clamp = function clamp(n, lowerBound, upperBound) {
      return Math.min(Math.max(n, lowerBound), upperBound);
    };

    var createMemoryHistory = function createMemoryHistory() {
      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var getUserConfirmation = props.getUserConfirmation,
          _props$initialEntries = props.initialEntries,
          initialEntries = _props$initialEntries === undefined ? ['/'] : _props$initialEntries,
          _props$initialIndex = props.initialIndex,
          initialIndex = _props$initialIndex === undefined ? 0 : _props$initialIndex,
          _props$keyLength = props.keyLength,
          keyLength = _props$keyLength === undefined ? 6 : _props$keyLength;
      var transitionManager = (0, _createTransitionManager2.default)();

      var setState = function setState(nextState) {
        _extends$$1(history, nextState);

        history.length = history.entries.length;
        transitionManager.notifyListeners(history.location, history.action);
      };

      var createKey = function createKey() {
        return Math.random().toString(36).substr(2, keyLength);
      };

      var index = clamp(initialIndex, 0, initialEntries.length - 1);
      var entries = initialEntries.map(function (entry) {
        return typeof entry === 'string' ? (0, LocationUtils.createLocation)(entry, undefined, createKey()) : (0, LocationUtils.createLocation)(entry, undefined, entry.key || createKey());
      });
      var createHref = PathUtils.createPath;

      var push = function push(path, state) {
        (0, _warning2.default)(!((typeof path === 'undefined' ? 'undefined' : _typeof$$1(path)) === 'object' && path.state !== undefined && state !== undefined), 'You should avoid providing a 2nd state argument to push when the 1st ' + 'argument is a location-like object that already has state; it is ignored');
        var action = 'PUSH';
        var location = (0, LocationUtils.createLocation)(path, state, createKey(), history.location);
        transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
          if (!ok) return;
          var prevIndex = history.index;
          var nextIndex = prevIndex + 1;
          var nextEntries = history.entries.slice(0);

          if (nextEntries.length > nextIndex) {
            nextEntries.splice(nextIndex, nextEntries.length - nextIndex, location);
          } else {
            nextEntries.push(location);
          }

          setState({
            action: action,
            location: location,
            index: nextIndex,
            entries: nextEntries
          });
        });
      };

      var replace = function replace(path, state) {
        (0, _warning2.default)(!((typeof path === 'undefined' ? 'undefined' : _typeof$$1(path)) === 'object' && path.state !== undefined && state !== undefined), 'You should avoid providing a 2nd state argument to replace when the 1st ' + 'argument is a location-like object that already has state; it is ignored');
        var action = 'REPLACE';
        var location = (0, LocationUtils.createLocation)(path, state, createKey(), history.location);
        transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
          if (!ok) return;
          history.entries[history.index] = location;
          setState({
            action: action,
            location: location
          });
        });
      };

      var go = function go(n) {
        var nextIndex = clamp(history.index + n, 0, history.entries.length - 1);
        var action = 'POP';
        var location = history.entries[nextIndex];
        transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
          if (ok) {
            setState({
              action: action,
              location: location,
              index: nextIndex
            });
          } else {
            setState();
          }
        });
      };

      var goBack = function goBack() {
        return go(-1);
      };

      var goForward = function goForward() {
        return go(1);
      };

      var canGo = function canGo(n) {
        var nextIndex = history.index + n;
        return nextIndex >= 0 && nextIndex < history.entries.length;
      };

      var block = function block() {
        var prompt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
        return transitionManager.setPrompt(prompt);
      };

      var listen = function listen(listener) {
        return transitionManager.appendListener(listener);
      };

      var history = {
        length: entries.length,
        action: 'POP',
        location: entries[index],
        index: index,
        entries: entries,
        createHref: createHref,
        push: push,
        replace: replace,
        go: go,
        goBack: goBack,
        goForward: goForward,
        canGo: canGo,
        block: block,
        listen: listen
      };
      return history;
    };

    exports.default = createMemoryHistory;
  });
  var createHistory = unwrapExports(createMemoryHistory_1);

  function hasPropType(Component, propType) {
    return !!Component.propTypes && propType in Component.propTypes;
  }

  function setupAppForTesting(App) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var _options$props = options.props,
        props = _options$props === void 0 ? {} : _options$props,
        mountOptions = _objectWithoutProperties(options, ["props"]);
    props = Object.assign({}, props);

    if (hasPropType(App, 'history') && !('history' in props)) {
      Object.assign(props, {
        history: createHistory()
      });
    }

    if (Object.getPrototypeOf(App) === React.Component) {
      Object.assign(props, {
        ref: function ref(app) {
          return setContext({
            app: app
          });
        }
      });
    }

    return mount(function () {
      return React.createElement(App, props);
    }, mountOptions).then(function () {
      if ('history' in props) {
        setContext({
          history: props.history
        });
      }

      return getContext('app', false) || null;
    });
  }

  function visit(location) {
    getContext('history').push(location);
  }
  function goBack() {
    getContext('history').goBack();
  }
  function goForward() {
    getContext('history').goForward();
  }
  function location() {
    return getContext('history').location;
  }

  exports.mount = mount;
  exports.cleanup = cleanup;
  exports.setupAppForTesting = setupAppForTesting;
  exports.visit = visit;
  exports.goBack = goBack;
  exports.goForward = goForward;
  exports.location = location;

  Object.defineProperty(exports, '__esModule', { value: true });

})));
