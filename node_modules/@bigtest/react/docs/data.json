[
  {
    "comment": "/**\n * Cleans up any component that was mounted by previously calling\n * `mount`, and clears the current context used by other helpers.\n *\n * The `teardown` option provided to the previous `mount` function\n * will be called when using this helper. If a promise is returned,\n * the cleanup will not happen until after that promise resovles.\n *\n * @function cleanup\n * @returns {Promise} Resolves after unmounting the component and\n * clearing the current context\n */",
    "meta": {
      "filename": "mount.js",
      "lineno": 20,
      "columnno": 0,
      "path": "/src",
      "code": {}
    },
    "description": "Cleans up any component that was mounted by previously calling\n`mount`, and clears the current context used by other helpers.\n\nThe `teardown` option provided to the previous `mount` function\nwill be called when using this helper. If a promise is returned,\nthe cleanup will not happen until after that promise resovles.",
    "kind": "function",
    "name": "cleanup",
    "returns": [
      {
        "type": {
          "names": [
            "Promise"
          ]
        },
        "description": "Resolves after unmounting the component and\nclearing the current context"
      }
    ],
    "longname": "cleanup",
    "scope": "global"
  },
  {
    "comment": "/**\n * Uses the history context setup during `setupAppForTesting` and\n * calls the `goBack` method.\n *\n * ``` javascript\n * // must be called to setup the `history` context\n * setupAppForTesting(App)\n *\n * // go to a route\n * visit('/someroute')\n *\n * // go back\n * goBack()\n * ```\n *\n * @function goBack\n * @throws Error When `setupAppForTesting` was not called\n */",
    "meta": {
      "filename": "visit.js",
      "lineno": 24,
      "columnno": 0,
      "path": "/src",
      "code": {}
    },
    "description": "Uses the history context setup during `setupAppForTesting` and\ncalls the `goBack` method.\n\n``` javascript\n// must be called to setup the `history` context\nsetupAppForTesting(App)\n\n// go to a route\nvisit('/someroute')\n\n// go back\ngoBack()\n```",
    "kind": "function",
    "name": "goBack",
    "exceptions": [
      {
        "description": "Error When `setupAppForTesting` was not called"
      }
    ],
    "longname": "goBack",
    "scope": "global"
  },
  {
    "comment": "/**\n * Uses the history context setup during `setupAppForTesting` and\n * calls the `goForward` method.\n *\n * ``` javascript\n * // must be called to setup the `history` context\n * setupAppForTesting(App)\n *\n * // go to a route, and back\n * visit('/someroute')\n * goBack()\n *\n * // go back to `/someroute`\n * goForward()\n * ```\n *\n * @function goForward\n * @throws Error When `setupAppForTesting` was not called\n */",
    "meta": {
      "filename": "visit.js",
      "lineno": 46,
      "columnno": 0,
      "path": "/src",
      "code": {}
    },
    "description": "Uses the history context setup during `setupAppForTesting` and\ncalls the `goForward` method.\n\n``` javascript\n// must be called to setup the `history` context\nsetupAppForTesting(App)\n\n// go to a route, and back\nvisit('/someroute')\ngoBack()\n\n// go back to `/someroute`\ngoForward()\n```",
    "kind": "function",
    "name": "goForward",
    "exceptions": [
      {
        "description": "Error When `setupAppForTesting` was not called"
      }
    ],
    "longname": "goForward",
    "scope": "global"
  },
  {
    "comment": "/**\n * Uses the history context setup during `setupAppForTesting`\n * and returns the current location.\n *\n * ``` javascript\n * // must be called to setup the `history` context\n * setupAppForTesting(App)\n * visit('/someroute')\n *\n * location().pathname\n * //=> \"/someroute\"\n * ```\n *\n * @returns {Object} Current history location object\n * @throws Error When `setupAppForTesting` was not called\n */",
    "meta": {
      "range": [
        1914,
        1985
      ],
      "filename": "visit.js",
      "lineno": 85,
      "columnno": 0,
      "path": "/src",
      "code": {
        "id": "astnode100000454",
        "name": "exports.location",
        "type": "FunctionDeclaration",
        "paramnames": []
      }
    },
    "description": "Uses the history context setup during `setupAppForTesting`\nand returns the current location.\n\n``` javascript\n// must be called to setup the `history` context\nsetupAppForTesting(App)\nvisit('/someroute')\n\nlocation().pathname\n//=> \"/someroute\"\n```",
    "returns": [
      {
        "type": {
          "names": [
            "Object"
          ]
        },
        "description": "Current history location object"
      }
    ],
    "exceptions": [
      {
        "description": "Error When `setupAppForTesting` was not called"
      }
    ],
    "name": "location",
    "longname": "location",
    "kind": "function",
    "scope": "global"
  },
  {
    "comment": "/**\n * Mounts the component within a freshly inserted dom node. If there\n * was a component previously mounted by this function, the `cleanup`\n * helper is automatically used to safely unmount it and clear any\n * existing context.\n *\n * ``` javascript\n * await mount(() => (\n *   <SomeComponent foo=\"bar\">\n *     <SomeOtherComponent/>\n *   </SomeComponent>\n * ))\n * ```\n *\n * The ID given to the mounting node can be customized by providing a\n * `mountId` option, and where the node is inserted into can be\n * controlled by providing a `rootElement`.\n *\n * The `setup` hook is called after cleaning up the previously mounted\n * component, and the new component is not mounted until after any\n * resulting promise resolves.\n *\n * The `teardown` hook is called on the next invokation of `cleanup`,\n * either by using it directly, or by calling `mount` again. Cleanup\n * will not complete until any optional promise returned from\n * `teardown` resolves.\n *\n * @function mount\n * @param {Component} component - The component to mount\n * @param {String} [options.mountId=\"testing-root\"] - The ID given to\n * the insterted mounting node.\n * @param {Node} [options.rootElement=document.body] - The root\n * element the new node will be insterted into.\n * @param {Function} [options.setup] - Called after cleaning up the\n * previously mounted component but before mounting the new\n * component. If a promise is returned, the component will not be\n * mounted until after the promise resolves.\n * @param {Function} [options.teardown] - Called when `cleanup` is\n * used after mounting the component, or when `mount` is used\n * again. If a promise is returned, the component will not be\n * unmounted until after the promise resolves.\n * @returns {Promise} Resolves after the component has been mounted\n * into the newly inserted DOM node.\n */",
    "meta": {
      "filename": "mount.js",
      "lineno": 51,
      "columnno": 0,
      "path": "/src",
      "code": {}
    },
    "description": "Mounts the component within a freshly inserted dom node. If there\nwas a component previously mounted by this function, the `cleanup`\nhelper is automatically used to safely unmount it and clear any\nexisting context.\n\n``` javascript\nawait mount(() => (\n  <SomeComponent foo=\"bar\">\n    <SomeOtherComponent/>\n  </SomeComponent>\n))\n```\n\nThe ID given to the mounting node can be customized by providing a\n`mountId` option, and where the node is inserted into can be\ncontrolled by providing a `rootElement`.\n\nThe `setup` hook is called after cleaning up the previously mounted\ncomponent, and the new component is not mounted until after any\nresulting promise resolves.\n\nThe `teardown` hook is called on the next invokation of `cleanup`,\neither by using it directly, or by calling `mount` again. Cleanup\nwill not complete until any optional promise returned from\n`teardown` resolves.",
    "kind": "function",
    "name": "mount",
    "params": [
      {
        "type": {
          "names": [
            "Component"
          ]
        },
        "description": "The component to mount",
        "name": "component"
      },
      {
        "type": {
          "names": [
            "String"
          ]
        },
        "optional": true,
        "defaultvalue": "\"testing-root\"",
        "description": "The ID given to\nthe insterted mounting node.",
        "name": "options.mountId"
      },
      {
        "type": {
          "names": [
            "Node"
          ]
        },
        "optional": true,
        "defaultvalue": "document.body",
        "description": "The root\nelement the new node will be insterted into.",
        "name": "options.rootElement"
      },
      {
        "type": {
          "names": [
            "function"
          ]
        },
        "optional": true,
        "description": "Called after cleaning up the\npreviously mounted component but before mounting the new\ncomponent. If a promise is returned, the component will not be\nmounted until after the promise resolves.",
        "name": "options.setup"
      },
      {
        "type": {
          "names": [
            "function"
          ]
        },
        "optional": true,
        "description": "Called when `cleanup` is\nused after mounting the component, or when `mount` is used\nagain. If a promise is returned, the component will not be\nunmounted until after the promise resolves.",
        "name": "options.teardown"
      }
    ],
    "returns": [
      {
        "type": {
          "names": [
            "Promise"
          ]
        },
        "description": "Resolves after the component has been mounted\ninto the newly inserted DOM node."
      }
    ],
    "longname": "mount",
    "scope": "global"
  },
  {
    "comment": "/**\n * Mounts an application component in the DOM with additional\n * properties useful for testing. Using the `props` option, you may\n * provide any custom properties to the app component.\n *\n * ``` javascript\n * setupAppForTesting(App, {\n *   props: { testing: true },\n *   setup: () => server = startMockServer(),\n *   teardown: () => server.shutdown()\n * })\n * ```\n *\n * If the application component accepts a `history` property, and one\n * was not already provided via `props`, an in-memory history object\n * is created which can then be used with routers such as [React\n * Router]().\n *\n * The `history` object is kept in a context which is used by the\n * `visit` helpers to make it easy to navigate your app. The `visit`\n * helpers will not work unless `setupAppForTesting` is called at\n * least once.\n *\n * ``` javascript\n * // `history` must be defined as a prop type\n * App.propTypes = {\n *   history: PropTypes.object\n * }\n *\n * // if this is not called, the visit helpers will throw errors\n * setupAppForTesting(App)\n *\n * // forwards to `history.push`\n * visit('/someroute')\n * visit({ pathname: '/foo', search: '?bar' })\n *\n * // other history helpers\n * goBack()\n * goForward()\n * ```\n *\n * Every time a new component is mounted via the `setupAppForTesting`\n * or `mount` helpers, or when using the `cleanup` helper, the\n * previous component is unmounted and the context is cleared.\n *\n * ``` javascript\n * setupAppForTesting(App)\n * visit('/someroute')\n * cleanup()\n *\n * visit('/someroute')\n * //=> Error: undefined history context\n * ```\n *\n * @function setupAppForTesting\n * @param {Component} App - The Application component class to mount\n * with additional properties\n * @param {Object} [options] - Mounting options passed along to `mount`\n * @param {Object} [options.props] - Additional props to pass to the\n * App component when it renders\n * @returns {Promise} Resolves with the app instance after it has been\n * mounted in the DOM\n */",
    "meta": {
      "filename": "setup-app.js",
      "lineno": 20,
      "columnno": 0,
      "path": "/src",
      "code": {}
    },
    "description": "Mounts an application component in the DOM with additional\nproperties useful for testing. Using the `props` option, you may\nprovide any custom properties to the app component.\n\n``` javascript\nsetupAppForTesting(App, {\n  props: { testing: true },\n  setup: () => server = startMockServer(),\n  teardown: () => server.shutdown()\n})\n```\n\nIf the application component accepts a `history` property, and one\nwas not already provided via `props`, an in-memory history object\nis created which can then be used with routers such as [React\nRouter]().\n\nThe `history` object is kept in a context which is used by the\n`visit` helpers to make it easy to navigate your app. The `visit`\nhelpers will not work unless `setupAppForTesting` is called at\nleast once.\n\n``` javascript\n// `history` must be defined as a prop type\nApp.propTypes = {\n  history: PropTypes.object\n}\n\n// if this is not called, the visit helpers will throw errors\nsetupAppForTesting(App)\n\n// forwards to `history.push`\nvisit('/someroute')\nvisit({ pathname: '/foo', search: '?bar' })\n\n// other history helpers\ngoBack()\ngoForward()\n```\n\nEvery time a new component is mounted via the `setupAppForTesting`\nor `mount` helpers, or when using the `cleanup` helper, the\nprevious component is unmounted and the context is cleared.\n\n``` javascript\nsetupAppForTesting(App)\nvisit('/someroute')\ncleanup()\n\nvisit('/someroute')\n//=> Error: undefined history context\n```",
    "kind": "function",
    "name": "setupAppForTesting",
    "params": [
      {
        "type": {
          "names": [
            "Component"
          ]
        },
        "description": "The Application component class to mount\nwith additional properties",
        "name": "App"
      },
      {
        "type": {
          "names": [
            "Object"
          ]
        },
        "optional": true,
        "description": "Mounting options passed along to `mount`",
        "name": "options"
      },
      {
        "type": {
          "names": [
            "Object"
          ]
        },
        "optional": true,
        "description": "Additional props to pass to the\nApp component when it renders",
        "name": "options.props"
      }
    ],
    "returns": [
      {
        "type": {
          "names": [
            "Promise"
          ]
        },
        "description": "Resolves with the app instance after it has been\nmounted in the DOM"
      }
    ],
    "longname": "setupAppForTesting",
    "scope": "global"
  },
  {
    "comment": "/**\n * Uses the history context setup during `setupAppForTesting` and\n * calls `push` with the provided location argument.\n *\n * ``` javascript\n * // must be called to setup the `history` context\n * setupAppForTesting(App)\n *\n * // calls `history.push()`\n * visit('/someroute')\n * visit({ pathname: '/foo', search: '?bar' })\n * ```\n *\n * @function visit\n * @param {Object|String} location - Argument for `history.push()`\n * @throws Error When `setupAppForTesting` was not called\n */",
    "meta": {
      "filename": "visit.js",
      "lineno": 3,
      "columnno": 0,
      "path": "/src",
      "code": {}
    },
    "description": "Uses the history context setup during `setupAppForTesting` and\ncalls `push` with the provided location argument.\n\n``` javascript\n// must be called to setup the `history` context\nsetupAppForTesting(App)\n\n// calls `history.push()`\nvisit('/someroute')\nvisit({ pathname: '/foo', search: '?bar' })\n```",
    "kind": "function",
    "name": "visit",
    "params": [
      {
        "type": {
          "names": [
            "Object",
            "String"
          ]
        },
        "description": "Argument for `history.push()`",
        "name": "location"
      }
    ],
    "exceptions": [
      {
        "description": "Error When `setupAppForTesting` was not called"
      }
    ],
    "longname": "visit",
    "scope": "global"
  }
]